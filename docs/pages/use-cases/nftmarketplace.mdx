import { Callout, Code, Tabs, Steps } from "nextra/components"

<Callout emoji="✍️">

Ledger Sync can provide developers with the necessary data they need to build their own NFT marketplace, or to enable the dApps to interact with the Marketplace through relevant queries. We will outline some common queries below:
>
> - [x] [1. Viewing Collections](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#1-query-the-total-ada-balance-in-a-wallet-address) 
> - [x] [2. Viewing NFT collection details](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#2-list-of-all-respective-utxos-that-compose-a-balance)
> - [x] [3. Viewing all assets available for sale](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#3-query-your-wallets-transaction-history-details)
> - [x] [4. Minting an NFT](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#4-list-a-breakdown-of-all-tokens-or-nfts-held-in-a-wallet)
> - [x] [5. Selling an NFT](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#5-query-the-asset-nft-collection-details-belonging-to-a-wallet-address)
> - [x] [6. Buying an NFT](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/nftmarketplace.mdx#6-query-token-metadata-information)

</Callout>

## 1. View Collections

NFT stands for non-fungible token. It is intended to be a unique token as in one and only one ever will be minted and no other token is then comparably equivalent to it. For this first query, we aim to find mint transactions with the label 721 in the metadata of the token. The 721 tag refers to the original standard for NFTs on Cardano as defined in [CIP-25](https://cips.cardano.org/cip/CIP-25).

Our query will return NFTs (label 721) collections in Cardano with their respective:

- asset collection name,
- Policy ID
- total supply
- creation date

<Callout type="info" emoji="ℹ️">
Remember you can also query the blockchain for this data using an explorer such as [cexplorer](https://cexplorer.io/collection)
</Callout>

## 2. Viewing NFT collection details

Now we will get more granular by quering for the data for a specif NFT collection. We'll search for details on *Spacebudz*, which made history by being the very first NFT collection minted on Cardano in March 2021.

![Spacebudz](/images/spacebudz.png)

### 2.1 Query the policy id

From the policy ID `d5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc` , we will fetch:

- The total number of assets in the collection.
- The number of transactions involving assets from the collection within the last 24 hours.

 
```sql
SELECT 
	ma."policy" AS collection_policy,
	count(*) AS number_of_assets,
		(SELECT 
		        count(DISTINCT tx.id) AS transaction_count_24h
			FROM tx
			JOIN block b ON b.id = tx.block_id 
			JOIN tx_out to2 ON to2.tx_id = tx.id 
			JOIN ma_tx_out mto ON to2.id = mto.tx_out_id
			JOIN multi_asset ma ON mto.ident = ma.id
			WHERE 
		             ma.policy = 'd5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc'
			     AND b."time" > (now() at time zone 'utc') - INTERVAL '24 hours'
			) AS number_of_tx_in_24h
		 FROM 
		       multi_asset ma
		 WHERE 
		       ma.policy = 'd5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc'
		 GROUP BY ma."policy"
```
<details>
<summary>
Expected results format
</summary>

```sql
collection_policy                                        | number_of_assets | number_of_tx_in_24h
---------------------------------------------------------+------------------+----------------------
d5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc |    10,000        | 75 
             
```

</details>

🔎 Let's take a closer look at each part of the query. 

`FROM multi_asset ma` specifies that the query will be looking at the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table, which stores information about assets on the Cardano blockchain.
`WHERE ma.policy = '...'` This filters the results to only include assets that belong to the collection identified by the  policy ID we provided.
`GROUP BY ma."policy"`  groups the results by the policy ID, ensuring that we get a single row summarizing the information for the entire collection.

Within the `SELECT` clause, `ma."policy" AS collection_policy` selects the policy ID of the collection and labels it as collection_policy. `count(*) AS number_of_assets`counts the number of rows (i.e., assets) in the filtered result set and labels it as `number_of_assets`.

The subquery is used to calculate the number of transactions involving assets from this collection within the last 24 hours.
`FROM tx JOIN block b ON b.id = tx.block_id JOIN tx_out to2 ON to2.tx_id = tx.id JOIN ma_tx_out mto ON to2.id = mto.tx_out_id JOIN multi_asset ma ON mto.ident = ma.id` joins several tables to link transactions ([tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx)), blocks ([block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block)), transaction outputs ([tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out)), and multi-asset information ([multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset)) together.

The `WHERE ma.policy = '...' AND b."time" > (now() at time zone 'utc') - INTERVAL '1 days'` clause filters the results to only include transactions involving assets from the specified collection that occurred within the last 24 hours.
`SELECT count(DISTINCT tx.id) AS transaction_count_24h` counts the number of distinct transaction IDs in the filtered result set and labels it as `transaction_count_24h`.

### 2.2 Asset details

This next query lists all assets/NFTs belonging to the Spacebudz collection with their respective:
- asset name + encoded name
- Asset ID
- minting (creation) date

```sql
SELECT
		ma.name_view AS asset_name,
		encode(ma.name, 'hex') AS encoded_name,
		ma.fingerprint AS Asset_ID,
		ma."time" AS creation_date
	FROM multi_asset ma 
	WHERE ma."policy" = 'd5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc'
```
<details>
<summary>
Expected results format
</summary>

```sql
asset_name   |  encoded_name             |  asset_id                                    | 	creation_date
-------------+---------------------------+----------------------------------------------+-------------------------
SpaceBud9007 | 	537061636542756439303037 | asset1qqcka5xwrzx40t7gaf2l4qd0k8latxqpkpq28h | 	2021-03-24 01:18:08.000
SpaceBud5511 | 	537061636542756435353131 | asset1x0pkcc6vf2v5ezhhj4hd9mls3pwwufvxy66rwp | 	2021-03-24 01:22:10.000
  ....       | 	....                     | 	......                                  | 	...

(Note: results trimmed for readability)             
```

</details>

🔎 Let's take a closer look at each part of the query. 

`FROM multi_asset ma` indicates that the query is targeting the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table, which stores information about assets (including NFTs) on Cardano. `WHERE ma."policy" = 'd5e6bf0500378d4f0da4e8dde6becec7621cd8cbf5cbb9b87013d4cc'` filters the results to only include assets that belong to the specific collection identified by the given policy ID.

`SELECT:
ma.name_view AS asset_name` retrieves the human-readable name of the asset and labels it as `asset_name`.

`encode(ma.name, 'hex') AS encoded_name` takes the raw asset name data `ma.name`, encodes it into a hexadecimal string representation, and labels it as `encoded_name`. `ma.fingerprint AS Asset_ID` selects the unique fingerprint (identifier) of the asset and labels it as `Asset_ID`. 

`ma."time" AS creation_date` retrieves the timestamp when the asset was created and labels it as `creation_date`.

### 2.3 Querying a specific NFT

Our last query fetches the following data about a specific NFT:
- asset name + encoded name
- asset metadata 
- owner (wallet address)
- mint date

```sql

SELECT 
	ma.name_view AS asset_name,
	encode(ma.name, 'hex') AS encoded_name,
	(SELECT tm.json FROM tx
               JOIN ma_tx_mint mtm ON mtm.tx_id = tx.id 
               JOIN tx_metadata tm ON tm.tx_id = tx.id
               JOIN multi_asset ma ON ma.id = mtm.ident
               WHERE ma.fingerprint = 'asset14y0ky8jeh009wcmyxcfnfakpgkuq0jcr8d5nxr' 
               		AND tm.key = 721
               ORDER BY mtm.id DESC LIMIT 1) AS asset_metatdata,
    tx_out.address AS owner_address,
    ma."time" AS mint_date
FROM 
    ma_tx_out mto
JOIN 
    multi_asset ma ON mto.ident = ma.id
JOIN 
    tx_out ON mto.tx_out_id = tx_out.id
LEFT JOIN 
    tx_in ti ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out.INDEX
LEFT JOIN 
	tx_metadata tm ON tm.tx_id = tx_out.tx_id
WHERE 
    ma.fingerprint = 'asset14y0ky8jeh009wcmyxcfnfakpgkuq0jcr8d5nxr'
    AND ti.tx_out_id IS NULL

```
<details>
<summary>
Expected results format
</summary>

```sql
asset_name	 |  encoded_name             |  asset_metadata                               | 	owner_address	
-------------+---------------------------+-----------------------------------------------+-------------------------
SpaceBud964  | 	5370616365427564393634   | 	{"d5e6bf0500378d4f0da4e8dde6be.....  }       | 	2021-03-24 01:18:08.000


(Note: results trimmed for readability)             
```
</details>

🔎 Let's take a closer look at each part of the query. 

The results returned include:

- **Asset Name**, ie. the human-readable name of the asset `ma.name_view`.
- **Encoded Name**... a hexadecimal representation of the asset's name `encode(ma.name, 'hex')`.
- **Metadata** associated with the asset, specifically looking for key `721` which is often used for NFT metadata `tm.json`. It selects the most recent metadata entry.
- **Owner Address**, the current address holding this asset `tx_out.address`.
- **Mint Date**, ie. the date and time when the asset was created `ma."time"`.


`FROM ma_tx_out mto` starts by looking at the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table, which tracks the association between native assets (tokens/NFTs) and transaction outputs.

`JOIN multi_asset ma ON mto.ident = ma.id` joins with the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table to get details about the asset itself, like its name and creation time.

`JOIN tx_out ON mto.tx_out_id = tx_out.id` joins with the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table to get information about the transaction output where this asset currently resides, including the owner's address.

`LEFT JOIN tx_in ti ON ...` attempts to join with the [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) table to find any transaction inputs that spend this specific transaction output.
`LEFT JOIN tx_metadata tm ON tm.tx_id = tx_out.tx_id` optionally joins with the [tx_metadata](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_metadata) table to fetch any metadata associated with the transaction that created the output holding the asset.

`WHERE ma.fingerprint = '...' AND ti.tx_out_id IS NULL` filters results to only include the asset with the specified fingerprint. The `ti.tx_out_id IS NULL` condition ensures that we only select the transaction output where the asset currently resides (i.e. it hasn't been spent in another transaction).

The subquery within the `SELECT` clause fetches the metadata associated with the asset's minting transaction


## 3. View all assets that are listed for sale

For this query, we want to list all assets that are listed for sale at an address. In other words, list all the assets locked in a specific smart contract address eg. `addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx` 

The query returns the following details:
- asset name & policy
- quantity 

```sql
SELECT
		ma.policy AS policy,
         	ma.name AS name,
		sum(mto.quantity) AS quantity
	FROM
		ma_tx_out mto
	JOIN multi_asset ma 
		ON ma.id = mto.ident 
	JOIN tx_out 
		ON mto.tx_out_id = tx_out.id
	LEFT JOIN tx_in ti 
		ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out."index"
	WHERE
		tx_out.address = 'addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx'
		AND ti.tx_out_id is null
	GROUP BY ma.policy, ma.name
	ORDER BY quantity DESC
```

<details>
<summary>
Expected results format
</summary>

```sql

policy	 												 |  name        |  quantity          
---------------------------------------------------------+--------------+--------------
64c11b97a1bc395f5cd3a6f2f594292510ae483af77151d1d6136edc | SNEKWRANGLER | 4,500,000,000  
52225d8259c95ec7d1727c8a591398846718eaa8fae533a1b8d2b9d6 | 	EL			| 1,000,000,000
1da3b63de574c7a103de734d8b1215b5ff5e3863d9fdecff8e09810c | 	FAM			| 439,678,272
ad5281e310da442d8d00ef3f7809cd0a1c035cf5039c0d90f236b7bc | 	FAM			| 439,000,000
daf494081cbb6872c6303d04697e5d10d4db8a69e4229beda69dd0af | 	CRAZYMARY	| 250,000,000
		....											 |   ...		|   ...

(Note: results trimmed for readability)             
```
</details>

🔎 Let's zoom in to understand at each part of the query. 

`FROM ma_tx_out mto` looking at the [ma_tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_out) table, which tracks the association between multi-assets and transaction outputs.

`JOIN multi_asset ma ON ma.id = mto.ident` joins the ma_tx_out table with the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table to get details about the assets themselves, such as their policy and name.

`JOIN tx_out ON mto.tx_out_id = tx_out.id` joins with the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table to get information about the transaction outputs where these assets reside, including the address that owns them.

`LEFT JOIN tx_in ti ON ...:` attempts a left join with the [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) table to identify any transaction inputs that might have spent these transaction outputs.

`WHERE tx_out.address = '...' AND ti.tx_out_id IS NULL` filters the results to only include assets held by the specified address.

The condition `ti.tx_out_id IS NULL` ensures that we only consider transaction outputs that haven't been spent yet.

`GROUP BY ma.policy, ma.name` groups the results by the policy and name of the assets, effectively aggregating multiple entries for the same asset (if they exist in different transaction outputs).

The `SELECT ma.policy AS policy, ma.name AS name, sum(mto.quantity) AS quantity` retrieves the following For each group (i.e., each unique asset): 
- The policy ID.
- The asset name.
- The total quantity of that asset held by the Address

`ORDER BY quantity DESC` sorts the results in descending order based on the quantity of each asset held.

## 4. Minting an NFT

For this query, we assume that the user and backend server have already generated the policyId, policy script, and the metadata necessary for minting NFTs, following [CIP-25](https://cips.cardano.org/cip/CIP-25) and [CIP-68](https://cips.cardano.org/cip/CIP-68) standards. In this example, we will focus on CIP-25. 

<Callout type="info" emoji="ℹ️">
Example of how to create a CIP-68 NFT can be found on GitHub, see [Nicholas Maselli's CIP-68 Showcase](https://github.com/NicholasMaselli/CIP-68Showcase)
</Callout>
 
Before proceeding, it’s important to understand the requirements for minting an NFT. Although the overall steps are documented on the [Cardano Developer Portal](https://developers.cardano.org/docs/native-tokens/minting-nfts/), it’s crucial to note that many of these steps are performed off-chain, typically by the application backend.

To successfully mint an NFT, the backend must query specific data from the database to construct the transaction. 

The required data includes:

- Protocol Parameters: These define various blockchain settings necessary for calculating transaction fees and other parameters.

- UTXOs: The Unspent Transaction Outputs associated with the wallet that will fund the minting transaction.

- Slot/Block Tip: The current slot or block tip to ensure the transaction is valid within the blockchain context.

### 4.1 Protocol parameters

```sql
        SELECT 
		    ep.epoch_no AS epoch,
		    ep.min_fee_a,
		    ep.min_fee_b,
		    ep.max_block_size,
		    ep.max_tx_size,
		    ep.max_bh_size as max_block_header_size,
		    ep.key_deposit,
		    ep.pool_deposit,
		    ep.max_epoch as e_max,
		    ep.optimal_pool_count as n_opt,
		    ep.influence as a0,
		    ep.monetary_expand_rate as rho,
		    ep.treasury_growth_rate as tau,
		    ep.decentralisation as decentralisation_param,
		    ep.extra_entropy,
		    ep.protocol_major AS protocol_major_ver,
		    ep.protocol_minor AS protocol_minor_ver,
		    ep.min_utxo_value AS min_utxo,
		    ep.min_pool_cost,
		    ep.nonce,
		    cm.costs AS cost_models,
		    ep.price_mem,
		    ep.price_step,
		    ep.max_tx_ex_mem,
		    ep.max_tx_ex_steps,
		    ep.max_block_ex_mem,
		    ep.max_block_ex_steps,
		    ep.max_val_size,
		    ep.collateral_percent,
		    ep.max_collateral_inputs,
		    ep.coins_per_utxo_size,
		    ep.coins_per_utxo_size as coins_per_utxo_word
		FROM 
		    epoch_param ep
		LEFT JOIN cost_model cm ON cm.id = ep.cost_model_id
		ORDER BY epoch_no DESC
		LIMIT 1

```

<details>
<summary>
Expected results format
</summary>

```sql

epoch | min_fee_a | min_fee_b | max_block_size | max_tx_size | max_block_header_size | key_deposit | pool_deposit | e_max | n_opt | a0 | rho | tau | decentralisation_param | extra_entropy | protocol_major_ver | protocol_minor_ver | min_utxo | min_pool_cost | nonce | cost_models | price_mem | price_step | max_tx_ex_mem | max_tx_ex_steps | max_block_ex_mem | max_block_ex_steps | max_val_size | collateral_percent | max_collateral_inputs | coins_per_utxo_size | coins_per_utxo_word
---------------------------------------------------------+--------------+--------------


(Note: results trimmed for readability)             
```
</details>

🔎 Looking a little closer, this query reads data from database, without modifying the blockchain itself. It retrieves information about the most recent epoch.

`SELECT` lists the specific columns to retrieve from the database tables.

`FROM epoch_param ep` specifies the main table to query, [epoch_param](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#epoch_param).

`LEFT JOIN cost_model cm ON cm.id = ep.cost_model_id` joins data from the [cost_model](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#cost_model) table based on matching id values.
`ORDER BY epoch_no DESC` sorts the results by `epoch_no` in descending order, ie. most recent epoch first.
`LIMIT 1` restricts the output to only the first row, ie. the most recent epoch's data.

### 4.2 UTXOs associated with specific address 

For this query, we are concerned with this address `addr1qyvl8lmwpfq7pahuadpjwul9xlj7c0atr5hvu4r3cjsjlfua276aqezvwjsfucvq76welxmytfyt7ug5835wntzzdvgsyxh7q9`

```sql
        SELECT 
		tx.hash AS txhash,
		to2."index" AS tx_out_index,
		to2.value AS value,
		to2.address 
	FROM tx_out to2 
	LEFT JOIN tx_in ti ON ti.tx_out_id = to2.tx_id AND ti.tx_out_index = to2."index"
	JOIN tx ON tx.id = to2.tx_id 
	WHERE 
		ti.id IS NULL
		AND to2.address = 'addr1qyvl8lmwpfq7pahuadpjwul9xlj7c0atr5hvu4r3cjsjlfua276aqezvwjsfucvq76welxmytfyt7ug5835wntzzdvgsyxh7q9'

```

<details>
<summary>
Expected results format
</summary>

```sql

txhash	 		|  tx_out_index |  value      | address      
----------------+---------------+-------------+----------------------
8cab5...f367073 | 	2 			| 	6,058,505 | addr1qyv...vgsyxh7q9
8cab5...f367073 | 	0			|   1,159,390 | addr1qyv...vgsyxh7q9
5ab5b...d7ba36 	| 	2			|   3,062,150 | addr1qyv...vgsyxh7q9
5ab5b...d7ba36  | 	1			|   1,159,390 | addr1qyv...vgsyxh7q9


(Note: results trimmed for readability)             
```
</details>

🔎 Looking a little closer, this query returns all unspent transaction outputs (UTXOs) associated with provided address.

`FROM tx_out to2` starts by selecting all transaction outputs from the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table and assigns them the alias `to2`.
`LEFT JOIN tx_in ti ON ti.tx_out_id = to2.tx_id AND ti.tx_out_index = to2."index"` performs a `LEFT JOIN` with the [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) table which stores transaction inputs.

The join condition matches `tx_out_id` and `tx_out_index` from [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) to the corresponding `tx_id` and index from [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out).

A `LEFT JOIN` ensures that all rows from [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) are included, even if there's no matching row in [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in).

`JOIN tx ON tx.id = to2.tx_id` performs an `INNER JOIN` with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table, which stores transactions.

This connects each transaction output `to2` to its corresponding transaction `tx` based on the `tx_id`.

`WHERE ti.id IS NULL` is the crucial part for identifying unspent outputs. It filters the results to only include rows where there's NO matching entry in [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in). In other words, these are outputs that haven't been used as inputs in any other transaction yet, hence they are "unspent".

`AND to2.address = 'addr1qyvl8lmwpfq7pahuadpjwul9xlj7c0atr5hvu4r3cjsjlfua276aqezvwjsfucvq76welxmytfyt7ug5835wntzzdvgsyxh7q9'` further filters the results to only show UTXOs belonging to our specific address.

`SELECT tx.hash AS txhash, to2."index" AS tx_out_index, to2.value AS value, to2.address` selects the following columns from the filtered results:
- `tx.hash` ..the transaction hash where the UTXO was created.
- `to2."index"` ...the index of the UTXO within the transaction.
- `to2.value` ...the ADA value (or other asset values) associated with the UTXO.
- `to2.address` ...the address that owns the UTXO

### 4.3 Chain Tip 

```sql

        SELECT
	    block.slot_no,
	    block.block_no,
	    block.epoch_no,
	    block.time
	FROM
	    block
	WHERE block.slot_no IS NOT NULL
	ORDER BY
	    block.slot_no DESC
	LIMIT 1;

```

<details>
<summary>
Expected results format
</summary>

```sql

slot_no	    | block_no	 | epoch_no | time
------------+------------+----------+------------------------
132,711,492 | 10,734,560 |   504    | 2024-08-21 22:03:03.000
           
```
</details>

🔎 Zooming in, this query retrieves information about the most recent block on the Cardano blockchain.

`SELECT block.slot_no, block.block_no, block.epoch_no, block.time` specifies which columns we want to retrieve from the database. It is looking for:

- `block.slot_no` ...the slot number in which the block was created.
- `block.block_no` ...the block number within its epoch.
- `block.epoch_no` ...the epoch number in which the block was created.
- `block.time` ...the timestamp when the block was created.

`FROM block` ...this tells the database that we want to get this information from a table called `block`.

`WHERE block.slot_no IS NOT NULL` is a filter ensuring that we only get rows (blocks) where the `slot_no` is not empty or null.

`ORDER BY block.slot_no DESC` sorts the results in descending order based on the `slot_no`. This means the block with the highest slot number (the most recent one) will be at the top.

`LIMIT 1` limits the output to only one row. Combined with the sorting, this ensures we only get the most recent block.


## 5. Selling an NFT

Selling, or listing, an NFT on a marketplace (often referred to as creating an "ask", where you offer assets in exchange for ADA) involves utilizing smart contracts. These contracts facilitate secure agreements between parties who may not necessarily trust each other.

For this exercise, we'll assume you're already familiar with the concept of smart contracts and understand how they operate. If not, consider reviewing resources such as the [Cardano Developer Portal](https://developers.cardano.org/docs/smart-contracts/) and the Aiken [EUTxO crash course](https://aiken-lang.org/fundamentals/eutxo) to name but a few. 

The first step in listing an NFT for sale is to create the necessary smart contracts. An example of such a contract can be found in the GitHub repositories of [JPG.Store](https://github.com/jpg-store/).

In our example, we will use the smart contract components for the following information: 

- **Datum**: Contains information such as the owner's public key hash (pkh), the assets being sold, and payout details (e.g., asset cost, artist royalties, marketplace service fees).

- **Redeemer**: Specifies what actions a user can take with the locked asset, such as “listing”,  “buying or accept“, “canceling”, or “update listing”.

- **Validator**: It ensures that the signer is the rightful owner, that payouts are correctly configured, and that the appropriate redeemer tag is present so transaction can be successfully processed.

These are on-chain components, where datum and redeemer information are stored  in the Ledger Sync database in CBOR and JSON format in the following tables: [datum](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#datum), [redeemer_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#redeemer_data), and also  referenced on [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) and [failed_tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#failed_tx_out). 

<Callout type="info" emoji="ℹ️">
Note: In case if you would like to decode the Datum, you can use [Datum Inspector - Cardanoscan](https://cardanoscan.io/datumInspector)
</Callout>

Before proceeding, ensure that you have created the script address for user to interact with the smart contract. 

At this stage, you probably have already implemented wallet connection functionality (e.g., via [CIP-30](https://cips.cardano.org/cip/CIP-30) or in another way), allowing your application to interact with users' wallets. 

On the Marketplace application, when a user clicks on "Sell", the application backend will build a transaction that matches the requirements of the smart contract. This includes:

1. Setting the datum with details like the owner of the public key hash, the asset being sold, and all required payouts: asset cost, royalties for the artist, and marketplace service fees. This information is necessary to lock the NFT in the smart contract address, making sure that all requirements are met (based on the smart contract created).

2. Including the redeemer code, in our example “listing” 

3. Providing the necessary transaction UTXOs and address inputs and outputs.

To successfully build the transaction, you'll need the following data, typically stored in the Ledger Sync database:

- **Protocol Parameters**: Define blockchain settings necessary for calculating transaction fees and other critical parameters.
- **UTXOs**: The Unspent Transaction Outputs associated with the wallet that will fund the transaction.
- **Slot/Block Tip**: The current slot or block tip to ensure the transaction is valid within the blockchain context.

Once the required data is gathered, the transaction can be built, signed through the user's wallet, and submitted on-chain. After submission, the validator (code running on-chain) will confirm that all conditions are met, and if so, the NFT will be transferred and locked at the smart contract address. 

Then, to view assets currently for sale on your marketplace, simply query the smart contract address created for the marketplace.

For example, you can check all assets on listings on the JPG.Store marketplace by visiting [this address](https://cardanoscan.io/address/addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx) on a Cardano Explorer. 

**Sources:**

- [JPG.Store Contract V2](https://github.com/jpg-store/contract-v2)
- [JPG.Store Contract V3](https://github.com/jpg-store/contracts-v3/blob/main/validators/ask.ak)
- [JPG.Store Next-Gen Smart Contract Update](https://medium.com/@jpgstorenft/unveiling-the-next-gen-smart-contract-update-for-jpg-store-2f883c913979)

In previous queries, we've already retrieved:
- Protocol parameters 
- UTXOs associated to the address below 
- Chain Tip 

Now we will retrieve all assets locked on a contract address and their respective: 

- Asset Name
- Asset policy ID
- Asset Fingerprint
- Amount

We will query this address `addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx`

```sql
SELECT
	    ma.policy AS policy,
	    ma.name AS name,
	    ma.fingerprint AS fingerprint,
	    sum(mto.quantity) AS quantity
	FROM
	    ma_tx_out mto
	JOIN multi_asset ma 
	    ON ma.id = mto.ident 
	    JOIN tx_out 
		ON mto.tx_out_id = tx_out.id
	LEFT JOIN tx_in ti 
		ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out."index"
	WHERE
	    tx_out.address = 'addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx'
	    AND ti.tx_out_id is null
	GROUP BY ma.policy, ma.name, ma.fingerprint
	ORDER BY quantity DESC
	LIMIT 10
```
<details>
<summary>
Expected results format
</summary>

```sql

policy	    											 | name	 					| fingerprint								   | quantity
---------------------------------------------------------+--------------------------+----------------------------------------------+--------------
64c11b97a1bc395f5cd3a6f2f594292510ae483af77151d1d6136edc | 	SNEKWRANGLER 			| asset13vuukdg8klkf6px6zt6jq2rqzs0l3gyvjyzhql | 4,500,000,000
52225d8259c95ec7d1727c8a591398846718eaa8fae533a1b8d2b9d6 | 	EL					    | asset1flkp5ddlknrdakpw72hmxwkkp0qkfuhlzzn5gw | 1,000,000,000
1da3b63de574c7a103de734d8b1215b5ff5e3863d9fdecff8e09810c | 	FAM						| asset1rs7t52lrfxrpz9p8f8egtwdlx4d33mqk62pyuu | 439,678,272
ad5281e310da442d8d00ef3f7809cd0a1c035cf5039c0d90f236b7bc | 	FAM						| asset1x77jxgfrnn00650gsdtxpuea3k2a6xslaf6key | 439,000,000
daf494081cbb6872c6303d04697e5d10d4db8a69e4229beda69dd0af | 	CRAZYMARY				| asset1uxza25kph43w2w6mstuspzmy47rvu4ks898q72 | 250,000,000
577f0b1342f8f8f4aed3388b80a8535812950c7a892495c0ecdf0f1e | 	\u0000\u0014�\u0010FLDT	| asset1gayaljphz3tepway6u6ruuty9cee2pj7wch408 | 180,000,000
05e1f8298560c85f03248a7b3e5322f12e27e4cdc1378a4f3bc51083 | 	ReebokaHoskinson		| asset18efh7djgsyat7m8j43etsusxhkv94940adss5k | 150,000,000
efa0e694d5915f52b00a0d01135efdb85a0bdde7009bbcf68ea12a3d | 	TV						| asset1lr06zsp4qzxv2emchq2j2mfwhqxzgtmxywrrvn | 50,000,000
e79497f972acb83461608d3f48281a406ee1e9f64ed168868145141e | 	StakePool247			| asset1946tqd3qe3hq3mxtzg4gkxqupnys0v9tr8v0zt | 25,000,000
15452b831185cdc3a18d27fea3fd30c9f765349352e523725c02b8f0 | 	SWS						| asset1968r7exh3296rls9axexyhqu3lk2c23mn5zjhz | 16,900,000
           
```
</details>

<Callout type="info" emoji="ℹ️">
Note that some results may display differently in some explorers compared to Ledger Sync results. This is because the 'decimal' parameter of each token may be set differently so a query may return the full data without dividing by decimal, while others divide by a decimal. This parameter is stored in the metadata registry. For the Ledger Sync database, the parameter is set to display the full data.
</Callout>


🔎 Looking closer, this query retrieves the top 10 most native assets held by our specific address.

`SELECT ma.policy, ma.name, ma.fingerprint, sum(mto.quantity) AS quantity` specifies the columns to be retrieved:
- `ma.policy` is the policy ID associated with the asset.
- `ma.name` is the name of the asset.
- `ma.fingerprint` is the unique fingerprint of the asset.
- `sum(mto.quantity) AS quantity` calculates the total quantity of each asset held by the address.

`FROM ma_tx_out mto` selects data from the [ma_tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_out) table, which stores information about asset transaction outputs.

`JOIN multi_asset ma ON ma.id = mto.ident` joins the [ma_tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_out) table with the multi_asset table based on matching `id` and `ident` values. This links the transaction output information with the details of the asset itself.

`JOIN tx_out ON mto.tx_out_id = tx_out.id` joins the result with the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table to get the transaction output details associated with the asset outputs.

`LEFT JOIN tx_in ti ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out."index"` performs a left join with the [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) table to identify which transaction outputs have been spent (used as inputs in other transactions).

`WHERE tx_out.address = 'addr1x8rjw3pawl0kelu4mj3c8x20fsczf5pl744s9mxz9v8n7efvjel5h55fgjcxgchp830r7h2l5msrlpt8262r3nvr8ekstg4qrx' AND ti.tx_out_id is null` filters the results to only include:
- Transaction outputs belonging to the specified  address.
- Transaction outputs that have not been spent (i.e., `ti.tx_out_id` is null). This ensures we're only looking at the unspent assets (the ones the address currently holds).

`GROUP BY ma.policy, ma.name, ma.fingerprint` groups the results by the policy, name, and fingerprint of the asset, allowing us to calculate the total quantity of each unique asset held.

`ORDER BY quantity DESC` sorts the results in descending order based on the calculated quantity. This puts the assets with the highest quantities at the top.

`LIMIT 10` limits the output to the top 10 results.


## 6. Buying an NFT

Buying an NFT on a marketplace (often referred to as placing a "bid," where you offer ADA in exchange for assets) involves the use of smart contracts. These contracts facilitate secure agreements between parties who may not necessarily trust each other.

For this exercise, we'll assume you're already familiar with the concept of smart contracts and understand how they operate. If not, consider reviewing resources such as the [Cardano Developer Portal](https://developers.cardano.org/docs/smart-contracts/) and the Aiken [EUTxO crash course](https://aiken-lang.org/fundamentals/eutxo) to name but a few. 

### Steps to Buy an NFT
The first step in buying an NFT is to select the one you want to make an offer on. To do this, refer to the “View Assets for Sale” query to see all assets listed on the marketplace.

After choosing the NFT, a similar process occurs as when you are selling an NFT (refer to the previous “Selling an NFT" example for details).

On the Marketplace application, when a user clicks on "Buy", the application backend will build a transaction that matches the requirements of the smart contract. This includes:

1. Setting the datum with details like amount of ada charged by the asset, royalties for the artist, and marketplace service fees. This steps are necessary to unlock the NFT in the transaction  making sure that all required payouts are fulfilled

2. Including the redeemer code, in our example “accept” (accept the offer/listing requirements).

3. Providing the necessary transaction UTXOs and address, inputs and outputs.

To successfully build the transaction, you'll need the following data, typically stored in the Ledger Sync database:

- **Protocol Parameters**: Define blockchain settings necessary for calculating transaction fees and other critical parameters.

- **UTXOs**: The Unspent Transaction Outputs associated with the wallet that will fund the transaction.

- **Slot/Block Tip**: The current slot or block tip to ensure the transaction is valid within the blockchain context.

Once the required data is gathered, the transaction can be built, signed through the user's wallet, and submitted on-chain. After submission, the validator will confirm that all conditions are met, and if so, and the NFT will be transferred to the buyer's wallet and if any, a change.

To make sure that the asset has been transferred from the smart contract address to your wallet, you can use the following query: [Breakdown list of all tokens or NFTs held in the wallet](https://github.com/johnnygreeney/LS/blob/main/wallet.md#4-list-a-breakdown-of-all-tokens-or-nfts-held-in-a-wallet)
