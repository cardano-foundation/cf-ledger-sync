import { Callout, Code, Tabs, Steps } from "nextra/components"

<Callout emoji="✍️">

By the end of this tutorial, you should be able to run the following queries leveraging Ledger Sync to gather the necessary data for building your own Cardano Wallet.
>
> - [x] [1. Query the total ADA balance in a wallet address](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#1-query-the-total-ada-balance-in-a-wallet-address) 
> - [x] [2. List of all respective UTXOs that compose a balance](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#2-list-of-all-respective-utxos-that-compose-a-balance)
> - [x] [3. Query your wallet's transaction history details](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#3-query-your-wallets-transaction-history-details)
> - [x] [4. List a breakdown of all tokens, or NFTs, held in a wallet](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#4-list-a-breakdown-of-all-tokens-or-nfts-held-in-a-wallet)
> - [x] [5. Query the Asset/ NFT collection details belonging to a wallet address](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#5-query-the-asset-nft-collection-details-belonging-to-a-wallet-address)
> - [x] [6. Query Token metadata information](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#6-query-token-metadata-information)
> - [x] [7. Query Active Stake Pools](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#7-query-active-stake-pools)
> - [x] [8. Query Stake Pool detailed information](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#8-query-stake-pool-detailed-information)
> - [x] [9. Query a stake pool's lifetime blocks](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#9-query-a-stake-pools-lifetime-blocks)
> - [x] [10. List the current dReps](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#10-list-the-current-dreps)
> - [x] [11. List of "Active Governance Proposals" and number of votes](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#11-list-of-active-governance-proposals-and-number-of-votes)
> - [x] [12. Query Smart contract transaction information](https://cardano-foundation.github.io/cf-ledger-sync/use-cases/wallet.mdx#12-query-smart-contract-transaction-information)

</Callout>

## 1. Query the total ADA balance in a wallet address 

Let's start with something simple but essential: **viewing your portfolio**. Specifically, we'll look at how to display the total balance of ADA holdings associated with a wallet address.

<Callout type="warning" emoji="⚠️">
Before we dive in, ensure that you have installed and configured Ledger Sync on your chosen network. Allow it to fully synchronize, and once the database is synced, you can start performing SQL queries using your preferred tool.
</Callout>

For most of our examples, we will query the same preprod address, which takes the following format:
`addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`

<Callout type="info" emoji="💡">
- You can get test tokens for pre-production and preview testnets using this [faucet](https://developers.cardano.org/docs/get-started/cardano-cli/get-started/)
- For SanchoNet tokens, go to the [SanchoNet faucet](https://sancho.network/faucet).
</Callout>

```sql
SELECT
    (coalesce(sum1.value,0) - coalesce(sum2.value,0)) as result
FROM
    (SELECT
        SUM(to1.value) as value
    FROM tx_out to1
    WHERE
        to1.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
    ) as sum1,
    
    (SELECT
        SUM(to2.value) as value
    FROM tx_in ti
    JOIN tx_out to2 ON
        ti.tx_out_id = to2.tx_id
        AND ti.tx_out_index = to2."index"
    WHERE
        to2.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
    ) as sum2;
```
<details>
<summary>
Expected results format
</summary>

```sql
4645032877132
```

</details>


There are few ways to obtain this information. In this SQL query, we calculate the balance of a specific address by subtracting the the total funds spent from the total funds received. In UTXO terms, we are subtracting the total value of spent outputs from the total value of received outputs. 

<Callout emoji="✍️">
 Note: Cardano (like Bitcoin) leverages the Unspent Transaction Output (UTXO) model to keep track of user state/balances. This is a different to the account-based model employed by Ethereum. Cardano implements an innovative Extended Unspent Transaction Output (EUTxO) model. If you are new to Cardano, or need a recap, the [EUTxO crash course](https://aiken-lang.org/fundamentals/eutxo) from the *Aiken* team is essential reading.  
</Callout>


🔎 Here's a breakdown of what the query does:

<Steps>

### Calculate the Balance between the following two sub-queries:

```sql
SELECT (COALESCE(sum1.value, 0) - COALESCE(sum2.value, 0)) as result 
FROM (subquery1) AS sum1, (subquery2) AS sum2
```

The main clause calculates the difference between the total received value `sum1.value` and the total spent value `sum2.value`. The `COALESCE` function is used to ensure that if either `sum1.value` or `sum2.value` is NULL, it is treated as '0'. The result is aliased as `result`. The `FROM` clause contains two nested subqueries, which are outlined next.

### Calculate Total Received Value:

```sql
SELECT SUM(to1.value) as value
FROM tx_out to1
WHERE to1.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
```

This first subquery `sum1` calculates the total value of all outputs sent (in lovelace) to the specified address `addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`. 
The `FROM tx_out to1` clause specifies the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table as the source and gives it the alias `to1` for easier reference. The `WHERE to1.address` clause filters the results to only include transactions for our address.

### Calculate Total Spent Value:

```sql
SELECT SUM(to2.value) as value
FROM tx_in ti
JOIN tx_out to2 ON
    ti.tx_out_id = to2.tx_id
    AND ti.tx_out_index = to2."index"
WHERE to2.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
```

This second subquery `sum2` calculates the total value of all outputs (in lovelace) from the specified address that have been spent. It does this by joining the [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) (alias `ti`) and [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) (alias `to2`) tables to find the corresponding spent outputs. 
The join condition ensures we only count outputs that were used as inputs in other transactions (i.e., spent funds). `WHERE to2.address` filters the results to only include transactions for our address and the result is also aliased as `value`.

### Conclusion:
This query effectively provides the current balance of the specified address by querying the database for:
- The total lovelace this has address received? (sum1)
- The total lovelace this address sent? (sum2)
- What's the difference between the two? (result)

Another way to check the balance is by summing up all the [UTXOs](https://docs.cardano.org/about-cardano/learn/eutxo-explainer/) associated with the wallet address.

</Steps>

##  2. List of all respective UTXOs that compose a balance

The goal of this query is to identify all Unspent Transaction Outputs (UTXOs) associated with one specific Cardano address. In simpler terms, it's like checking the individual coins and tokens in the wallet that haven't been spent yet.

```sql
SELECT
	tx.hash AS tx_hash,
	txo."index" AS tx_out_index,
	d.hash AS datum_hash,
	s.hash AS script_hash
FROM tx_out txo
LEFT JOIN tx_in ti 
	ON ti.tx_out_index = txo."index" AND ti.tx_out_id = txo.tx_id 
JOIN tx
	ON tx.id = txo.tx_id
LEFT JOIN datum d ON d.id = txo.inline_datum_id  
LEFT JOIN script s ON s.id = txo.reference_script_id  
WHERE
    txo.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
    AND ti.id IS NULL
```

<details>
<summary>
Expected results format
</summary>


```sql
     tx_hash                                                     | tx_out_index |    value       | datum_hash | script_hash
-----------------------------------------------------------------+--------------+----------------+------------+------------ 
74042d7fa5340a525d6c3f77f446d45efc6830332672e7acbf4241256f65b42f |     0        |  3228190       |            |           
74042d7fa5340a525d6c3f77f446d45efc6830332672e7acbf4241256f65b42f |     1        |  4605029648942 |            |            
aa138cb7581757deff37d320f9d6c7a1632607cb76a4615cbc0c1b517a15fb18 |     0        |  40000000000	 |            |                 
(3 rows)
```

</details>

<Callout type="info" emoji="💡">
It's important to understand how UTxOs are referenced on Cardano. As shown below, a UTxO consists of the reference to the transaction that created it (TxId), and its index (TxIx) on the host transaction. A UTxO is associated with an asset value, an address which dictates its spending conditions and other metadata. A transaction can take multiple inputs (consuming multiple UTxOs) and produce multiple outputs (new UTxOs to be used by future transactions).
![txidindex](/images/txid.png)
</Callout>

🔎 Let's breakdown how this query works. 

<Steps>

### 'SELECT'ing the information, ie. retrieving the UTXOS:

Specifically, we are looking for:
- `tx.hash` The unique id (hash) of the transaction.
- `txo."index"` The index (position) of the UTXO within the transaction.
- `d.hash` The hash of any associated datum (think of this as optional additional data attached to the UTXO).
- `s.hash` (Optional) The hash of any associated script (an optional script detailing the conditions for spending the UTXO).

### Table JOINs

- `tx_out txo` table with information about transaction outputs.
- `tx_in ti` table with information about transaction inputs. We join these tables so we can check if a UTXO has been spent, i.e., used as an input.
-  This `tx` table holds general transaction information.
- `datum d` & `script s` tables hold optional extra data about the UTXO. We use LEFT JOIN because not all UTXOs will have datum or scripts attached.


### Filters
- Filters results for our specific address
`txo.address = addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`
- `ti.id IS NULL` is an important condition as it ensures we only get unspent UTXOs, i.e. UTXOs that haven't been used as inputs yet.

### How the query works
- The query starts by looking at all transaction outputs `tx_out`.
- It verifies each output belongs to our specific address.
- It looks for matches in the `tx_in` table to see if the output has been used as an input.
- If no match is found, `ti.id IS NULL`, then it's an unspent UTXO.
- Finally, it fetches any additoinal information about the optional datum and script, if they exist, and presents the results.

### Conclusion
Now that you know your balance, you might want to see where it came from. To do this, we'll create a query to fetch the transaction history associated with this address and display it in a list, including additional details for each transaction.

</Steps>

## 3. Query your wallet's transaction history details 

For consistency, we will query the same preprod address as before: 
`addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`

🔎 You can also inspect this address on [Cardano explorer](https://preprod.beta.explorer.cardano.org/en/address/addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t) (remember to choose 'Preprod' in the top right)

![preprod](/images/preprod.png)


### 3.1 Transaction details

First, we want to query the following transaction details: 
- amount of ADA transferred
- if the transaction is incoming/outgoing
- transaction fee 
- assets (name and quantity) 
- transaction hash 
- Timestamp 
- Slot/Block 

```sql
-- Transactions where the address is the output
SELECT
	COALESCE(sum(tx_out.value),	0) - COALESCE(inp.inp_value, 0) AS ADA_amount,
	'outgoing' AS direction,
	tx.fee AS fee,
	tx.hash AS tx_hash,
	block."time" AS time_stamp,
	block.block_no AS block,
	block.slot_no AS slot
FROM tx_out
JOIN tx ON tx.id = tx_out.tx_id
LEFT JOIN ( SELECT
		tx.id AS inp_txid,
		tx.hash AS inp_hash,
		tx_out.address AS source_add,
		sum(tx_out.value) AS inp_value
           FROM tx_in
	   JOIN tx_out ON tx_out.tx_id = tx_in.tx_out_id
		    AND tx_out.index = tx_in.tx_out_index
    	   JOIN tx ON tx.id = tx_in.tx_in_id
	   WHERE
		tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
           GROUP BY
		inp_txid,
		inp_hash,
		source_add
    		) 
    	AS inp ON inp.inp_txid = tx.id
JOIN block ON block.id = tx.block_id
WHERE
	tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
GROUP BY
	tx_hash,
	direction,
	fee,
	time_stamp,
	block,
	slot,
	inp.inp_value


UNION


-- Transactions where the address is the output and not an output
SELECT
    sum(tx_out.value) AS ADA_amount,
	'incoming' AS direction,
	tx.fee AS fee,
	tx.hash AS tx_hash,
	block."time" AS time_stamp,
	block.block_no AS block,
	block.slot_no AS slot
FROM tx_in
JOIN tx_out ON tx_out.tx_id = tx_in.tx_out_id
			AND tx_out.index = tx_in.tx_out_index
JOIN tx ON tx.id = tx_in.tx_in_id
JOIN block ON block.id = tx.block_id
WHERE
	tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
	AND NOT EXISTS (SELECT 1 AS txid
					FROM tx_out
					WHERE
						tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
						AND tx_out.tx_id = tx.id )
GROUP BY
	tx_hash,
	direction,
	fee,
	time_stamp,
	block,
	slot
```

<details>
<summary>
Expected results format
</summary>


```sql
     ada_amount	  | direction |  fee    |                         tx_hash                                  |      time_stamp       |   block   |  slot
------------------+-----------+---------+------------------------------------------------------------------+-----------------------+-----------+------------
2,000,000,000,000 | outgoing  | 174,961 | 17abe1200ebe4b801d830f8c216a421dcff778ed82b1f83198acd403b2938384 | 2024-02-05 20:13:48.00| 1,899,032 |  51,480,828
    -199,601      | outgoing  | 199,601	|  8eb504479c678b0a1d0073b3420f0b62df9ca98b7e503005f157580c010e1d0f| 2023-07-10 02:37:30.00| 1,143,600 |  33,273,450
39,735,569,942	  | outgoing  | 177,469 |  8ffaafe1dde6f78d6b742d94c9f1a21c892389d9fa73861211356687b751cf66| 2023-12-12 04:39:20.00| 1,692,918 |  46,672,760
             
(Note: results trimmed for readability)
```

</details>

The overall aim is to track the flow of ADA for our specific address. It categorizes transactions as 'outgoing' or 'incoming' and provides details like the amount, fee, timestamp, and block information. 

<Callout type="info" emoji="💡">
- When we say "outgoing", this is the address that is in the output of that transaction, and possibly the input as well.
- When we say "incoming", this is the address in the input part of that transaction, and not in the output part.
</Callout>

🔎 Let's take a closer look at each part of the query. 

<Steps>

### First Part (Before UNION)

`SELECT COALESCE(sum(tx_out.value), 0) - COALESCE(inp.inp_value, 0) AS ADA_amount, 'outgoing' AS direction, ...`

This SELECT statement calculates the net ADA amount involved in transactions where the given address is an output, ie. recipient.
`COALESCE` ensures that if `sum(tx_out.value)` or `inp.inp_value` is NULL, they are treated as 0, preventing errors.
`outgoing` labels these transactions as outgoing.

`FROM tx_out JOIN tx ON tx.id = tx_out.tx_id ...` 
This FROM statement starts by looking at [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) (transaction outputs) and joins it with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) 
(transactions) table, linking them based on transaction IDs.

`LEFT JOIN ( SELECT ... ) AS inp ON inp.inp_txid = tx.id` is a subquery aliased as `inp`. It looks for transactions where the given address is an input (or sender) and calculates the total input value `inp_value` for those transactions. 

`LEFT JOIN` includes all rows from the left table [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) even if there's no match in the subquery `inp`. 

`JOIN block ON block.id = tx.block_id` joins the [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block) table to get block-related information (timestamp, block number, slot number).

`WHERE tx_out.address = '...'` filters results to only include transactions where the specified address is an output. `GROUP BY tx_hash, ...` groups the results by transaction hash and other fields to avoid duplicate rows.

`UNION` combines the results of the first part with the second part.

### Second Part (After UNION)

`SELECT sum(tx_out.value) AS ADA_amount, 'incoming' AS direction, ...` calculates the total ADA amount for incoming transactions. 

`incoming` labels these transactions as incoming. `FROM tx_in JOIN tx_out ON ... JOIN tx ON ... JOIN block ON ...` similar joins as in the first part, but starts from [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) (transaction inputs).

`WHERE tx_out.address = '...' AND NOT EXISTS (SELECT 1 AS txid FROM tx_out WHERE ...)` filters to include transactions where:
- The address is an input (via [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) linked to [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in)).
- The address is not an output in the same transaction (using NOT EXISTS).

`GROUP BY tx_hash, ...` groups the results similarly to the first part.
</Steps>

### 3.2 Retrieve Transaction signatories

Next we will run a query to get the transaction signatories. :writing_hand:

We will query the transaction hash `3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7` as it has more than one signer keys.

```sql
SELECT tw."key" AS Transaction_Signatories
			FROM tx
			LEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id
			WHERE tx.hash = '3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7'
```

<details>
<summary>
Expected results format
</summary>

```sql
     transaction_signatories
----------------------------------------------------------------
1fdbf347cae52d54a9cf7f58e4ecf461144bbfb38a330dce3e8d66f1391bc442
55ff3b5b6603609463566057e0713cb2db512838eb864a0c15d73b377c278ae3

(2 rows)
```

</details>


🔎  Let's take a closer look at each part of the query. 

`SELECT tw."key" AS Transaction_Signatories` selects the `key` column from the [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) table and renames it as `Transaction_Signatories` in the output.

`FROM tx` means the query is looking in the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table.

`LEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id` performs a LEFT JOIN with the [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) table.
`LEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id` performs a LEFT JOIN with the [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) table.

The join condition `tx.id = tw.tx_id` connects rows from both tables where the `id` in the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table matches the `tx_id` in the [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) table.

`LEFT JOIN` ensures that all rows from the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table are included in the result, even if there's no corresponding match in the [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) table. In such cases, the columns from [tx_witnesses](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_witnesses) will have NULL values.

`WHERE tx.hash = '3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7'` is a filtering condition restricting the output to only those rows where the hash column in the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table matches the provided specific hash value.

### 3.3 Retrieve Transaction signatories

While reviewing the above transactions, you might notice that some include more than just ADA, they also include *[Cardano Native Assets](https://developers.cardano.org/docs/get-started/cardano-cli/native-assets/)*.

Next we will run a query get the details of a specific transaction which includes a native asset. We will query the transaction hash `3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7` because this transaction has native assets, in addtion to ada.

```sql

SELECT tx_detail.* FROM (	
			SELECT 
				'output' AS direction,
				tx_out.address AS address,
				sa."view" AS stake_address,
				tx_out.value AS ADA_amount,
				ma.name AS asset_name,
				sum(mto.quantity) AS quantity,
				b.time AS time_stamp,
				tx.fee AS transaction_fee,
				b.block_no AS block,
				b.slot_no AS slot,
				NULL AS utxo
			FROM tx
				LEFT JOIN tx_out ON tx_out.tx_id = tx.id
				LEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id
				LEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id
				LEFT JOIN multi_asset ma ON ma.id = mto.ident
				LEFT JOIN block b ON b.id = tx.block_id
			WHERE
				tx.hash = '3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7'
			GROUP BY direction, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, utxo
				
			UNION ALL

			SELECT 
				'input' AS direction,
				tx_out.address AS address,
				sa."view" AS stake_address,
				tx_out.value ADA_amount,
				ma.name AS asset_name,
				sum(mto.quantity) AS quantity,
				b.time AS time_stamp,
				tx.fee AS transaction_fee,
				b.block_no AS block,
				b.slot_no AS slot,
				txin.hash AS utxo
			FROM tx
				LEFT JOIN tx_in ti ON ti.tx_in_id = tx.id
				LEFT JOIN tx_out ON tx_out.tx_id = ti.tx_out_id AND tx_out."index" = ti.tx_out_index 
				LEFT JOIN tx txin ON txin.id = tx_out.tx_id
				LEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id
				LEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id
				LEFT JOIN multi_asset ma ON ma.id = mto.ident
				LEFT JOIN block b ON b.id = tx.block_id
			WHERE
				tx.hash = '3565bb0621d56ff3349f014a41c7c4c9f5614288a4b00abbe76d3b41becc9da7'
			GROUP BY direction, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, utxo
				) AS tx_detail
ORDER BY tx_detail.direction ASC
```

<details>
<summary>
Expected results format
</summary>

```sql
direction  | address 			  |  stake_address	             | ada_amount    | asset_name | quantity |  time_stamp  | transaction_fee| block  | slot    |  utxo	
-----------+------------------------------+----------------------------------+---------------+------------+----------+--------------+----------------+--------+---------+---------------
input      | addr_test1qr...09cae0svmt57t | stake_test1urfvl...8juwuhclq5pxz | 4531923278317 | tDRIP      | 1000020  |  2024-04-03  | 196917         | 2106415| 56425275| a55dca...ff747
 
(Note: results trimmed for readability)
```

</details>


🔎  Let's zoom in for a closer look at each part of the query. 

<Steps>
### Two Subqueries Combined with UNION ALL

The main query selects everything prefixed `tx_detail` by combining the results of two subqueries using `UNION ALL` which appends the results of the second subquery to the first, without removing duplicates.

### First Subquery focuses on Outputs

`SELECT 'output' AS direction, ...` labels each row as an 'output'.
`FROM tx LEFT JOIN tx_out ...` starts from the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table and joins with [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) (transaction outputs) table to get output details.
`LEFT JOIN stake_address ...` joins with `stake_address` to get associated stake address information.
`LEFT JOIN ma_tx_out ... LEFT JOIN multi_asset ...` joins to gather details about any native assets involved in the outputs.
`LEFT JOIN block b ...` joins with [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block) to get block-related info.  
`WHERE tx.hash = '...'` filters to focus only on the specific transaction.
`GROUP BY ...` groups results to avoid redundancy, especially when multiple native assets are involved in an output.
`NULL AS utxo` sets the utxo column to `NULL` for outputs, as UTXOs are relevant to inputs.

### Second Subquery focuses on Inputs

`SELECT 'input' AS direction, ...` labels each row as an 'input'.
`FROM tx LEFT JOIN tx_in ...` starts from [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table and joins with [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) (transaction inputs) table.
`LEFT JOIN tx_out ... LEFT JOIN tx txin ...` traces back from the input to the original output it's spending, to get details about that output.
Other joins and `WHERE` clause are similar to the first subquery.
`txin.hash AS utxo` includes the hash of the transaction that created the spent output, representing the UTXO.

### Main Query

`SELECT tx_detail.* FROM (...) AS tx_detail` selects all columns from the combined results of the subqueries.
`ORDER BY tx_detail.direction ASC` orders the results, showing outputs first, then inputs.

In summary, this query gives you a detailed breakdown of what went into and came out of the Cardano transaction we are interested in.

Next, we will run a query to fetch a breakdown list of all the native tokens (both fungible tokens and NFTs) held in the wallet. This will provide a detailed view of your various assets, allowing you to see each token or NFT along with its name and quantity.
</Steps>

## 4. List a breakdown of all tokens, or NFTs, held in a wallet

Some assets, particularly NFTs, may include additional information detailed in their metadata. For instance, in-game NFTs can have attributes such as power, speed, and strength encoded in this metadata. This information follows the standards set by [CIP-25](https://cips.cardano.org/cip/CIP-25), which defines how metadata should be structured for assets on the Cardano blockchain. 

<Callout type="info" emoji="💡">
Metadata standards for Cardano are covered in CIPs (Cardano Improvement Proposals) [25](https://cips.cardano.org/cip/CIP-25), [25](https://cips.cardano.org/cip/CIP-0026), [60](https://cips.cardano.org/cip/CIP-0060) and [68](https://cips.cardano.org/cip/CIP-0068)
</Callout>

To keep things simple, we will use the same address as before: 

`addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`

🔎 You can also verify the details on [Cardano Blockchain Explorer](https://preprod.beta.explorer.cardano.org/en/address/addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t) 🎯

To retrieve the metadata, you can use the following query:

```sql
SELECT
	ma.fingerprint,
    ma.name AS name,
    sum(mto.quantity) AS quantity
FROM
    ma_tx_out mto
JOIN multi_asset ma 
	ON ma.id = mto.ident 
JOIN tx_out 
	ON mto.tx_out_id = tx_out.id
LEFT JOIN tx_in ti 
	ON ti.tx_out_index = tx_out."index" AND ti.tx_out_id = tx_out.tx_id 
WHERE
    tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'
    AND ti.tx_out_id is null
GROUP BY ma.fingerprint, ma.name
```

<details>
<summary>
Expected results format
</summary>

```sql
     fingerprint                              |       name      |    quantity
----------------------------------------------+-----------------+--------------- 
asset1anpme6pcrc4jax2h230gm4pgmwsz80u27qsufq  | tBigTokenName03 |     20           
asset1etk8c8pscc0f6hy6q4wc3nphk9znj0xagv9acz  | tBigTokenName01 |     20                
asset1gvxdk7yhzupnruv9h54jc9eenf30w55xuq43vf  | tBigTokenName05 |     20         
asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm  |     tDRIP       |  1,000,020
asset1qftk8hza6hn50lm2pl88wl8gea5fan5zhgx8gm  | tBigTokenName10 |     10
asset1rpsx8nx8gzmwt62tuzdwq66qj8jrdmsgjv6qsa  | tBigTokenName08 |     20
asset1t87nuhlan33l68hhtgmt3zfks3lwupayncz0k3  | tBigTokenName07 |     20
asset1tfpfjaz57vpcddwzxdz49f8pc7zmlswjfjfwwx  | tBigTokenName04 |     20
asset1uvkv85rk6pklfcdm39ht0yq60pf2fawtwndu2w  | tBigTokenName06 |     20
asset1vyddw8jc6w9679smf4d4d8r4qn7g2pzkqhgktd  | tBigTokenName02 |     20
asset1zutmprtn8te56av95m09sxj305rxm7yps3e3vr  | tBigTokenName09 |     20            
(11 rows)
```

</details>

At a high level, we are listing all the distinct tokens (fungible tokens) and NFTs (non-fungible tokens) present in our specific Cardano wallet address, along with their respective quantities. This is essential for wallet applications to display a user's asset holdings accurately. We are chcking unspent Multi-Asset transaction output from the [ma_tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_out) table for our specific address. 🔎 Let's break it down line by line:

<Steps>
### SELECT the right information:

- `ma.fingerprint` ,ie. the unique fingerprint of the token/NFT.
- `ma.name` ...this is the name of the token/NFT (often used to distinguish NFTs).
- `sum(mto.quantity)`, ie. the total quantity of that specific token/NFT held in the wallet, calculated by summing quantities across UTXOs.

### Table JOINs

- `ma_tx_out mto` table stores information about multi-asset quantities within transaction outputs.
- `multi_asset ma` table stores the metadata for each multi-asset.
- `tx_out` table stores general transaction output information.
- `tx_in ti` table stores transaction input information. We use this to check if a UTXO is spent.

### Filters

- `tx_out.address = 'addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t'`...we are filtering for our specific wallet address.
- `ti.tx_out_id IS NULL` is an important condition ensuring we only consider unspent transaction outputs (UTXOs) since those are the ones containing the assets currently held in the wallet.

### Grouping and Aggregating

- `GROUP BY ma.fingerprint, ma.name` clause groups the results by the unique fingerprint and name of each token/NFT, enabling us to calculate the total quantity held.
- `SUM(mto.quantity)` calculates the total quantity of each token/NFT by summing up the quantities found in all relevant UTXOs.

### Conclusion

- The query looks at all transaction outputs `tx_out` containing multi-assets.
- It checks if the outputs belong to the specified wallet address and are unspent.
- It retrieves the fingerprint and name of the multi-asset from the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table.
- It groups the results by fingerprint and name, summing up the quantities to get the total amount of each token/NFT held at our wallet address.
- It returns a list of all the distinct tokens and NFTs in the wallet, along with their respective quantities.
</Steps>

## 5. Query the Asset/ NFT collection details belonging to a wallet address

To keep things simple, we will use the same address as before: 

`addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t`

🔎 You can also verify the details on [Cardano Blockchain Explorer](https://preprod.beta.explorer.cardano.org/en/address/addr_test1qr70pedl22tnzswcfm39nqvsfan9jgtym2k0lgrftga8j67jel8q0vyag8770e8pu3rf6he70dtrexrsg6waj09cae0svmt57t) 🎯

For this example, we are querying this specific token `asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm`. We want to retrieve the following details: a) Script hash, b) Total supply, c)creation date, d) Number of holders, e) Number of transactions in the past week.

```sql
SELECT
		ma.policy AS scriptHash,
		ma.supply AS totalSupply,
		ma.time AS createdDate,
		num_of_holders.numHolder,
		num_of_tx.numTx
	FROM
		preprod.multi_asset ma
	LEFT JOIN (
				SELECT ma.fingerprint AS fingerprint, COUNT(DISTINCT tx.id) AS numTx
				FROM tx
				LEFT JOIN tx_out txo ON tx.id = txo.tx_id 
				JOIN block b ON b.id = tx.block_id 
				JOIN ma_tx_out mto ON txo.id = mto.tx_out_id
				JOIN multi_asset ma ON mto.ident = ma.id
				WHERE
				   ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'
				   AND b.time > (now() at time zone 'utc') - INTERVAL '7 days'
				GROUP BY ma.fingerprint
				) AS num_of_tx ON num_of_tx.fingerprint = ma.fingerprint
	LEFT JOIN (
				SELECT ma.fingerprint AS fingerprint, COUNT(DISTINCT(sa.id)) AS numHolder
				FROM ma_tx_out mto
				LEFT JOIN tx_out to2 ON mto.tx_out_id = to2.id
				LEFT JOIN tx_in ti ON ti.tx_out_index = to2."index"
									AND ti.tx_out_id = to2.tx_id
				JOIN multi_asset ma ON ma.id = mto.ident
				LEFT JOIN stake_address sa ON sa.id = to2.stake_address_id
				WHERE
					ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'
					AND ti.id IS NULL
					AND sa.id IS NOT NULL
				GROUP BY ma.fingerprint
				) AS num_of_holders ON num_of_holders.fingerprint = ma.fingerprint
	WHERE
		ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'
```

<details>
<summary>
Expected results format
</summary>

```sql

     scripthash                                          |      totalsupply       |        createddate |datum_hash | numtx
---------------------------------------------------------+------------------------+--------------------+-----------+------- 
698a6ea0ca99f315034072af31eaac6ec11fe8558d3f48e9775aab9d | 45,000,000,000,000,000 | 2022-12-12 18:28:01|  1,046    |  33           
    
(1 rows)
```

</details>

🔎 We can always cross check our results on any Cardano Explorer, such as [cexplorer](https://preprod.cexplorer.io/policy/698a6ea0ca99f315034072af31eaac6ec11fe8558d3f48e9775aab9d#data) 🎯

🧐 Let's breakdown the query line by line:

<Steps>

### Data Sources

The query traverses multiple tables to find the requested details:

- `multi_asset` (alias ma) table stores information about the asset itself.
- `tx`, ie. transaction data.
- `tx_out` Transaction output data, where assets end up after a transaction.
- `block` refers to blockchain block data. Transactions are grouped into blocks.
- `ma_tx_out` table links multi-asset entries to transaction outputs.
- `stake_address` table stores information about wallet addresses.

### Main Query (SELECT...FROM)

- The query starts by selecting the desired columns from the [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table.
- It filters for the target asset using it's unique fingerprint `asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm`

### First Subquery (LEFT JOIN...num_of_tx)

- This subquery calculates the number of transactions within the past 7 days for our specific asset.
- It joins transaction data with block data to filter by time.
- It groups the results by the asset's fingerprint and counts distinct transaction IDs.

### Second Subquery (LEFT JOIN...num_of_holders)

- This subquery calculates the number of distinct holders of the asset.
- It queries transaction outputs `tx_out` and the links to multi-assets.
- It filters out transaction outputs that are inputs to other transactions.
- It counts distinct stake addresses associated with the remaining outputs, where each address represents a holder.

### Joining Subqueries

- The main query uses a `LEFT JOIN` to combine the results of the two subqueries back to the main [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table.
- The LEFT JOIN ensures that the main query returns a row even if the subqueries don't find matching data (in that case, `num_of_tx` and `num_of_holders` would be NULL).

### Conclusion

- A fingerprint is a unique identifier used to distinguish different assets on the Cardano blockchain.
- The `LEFT JOIN` type of join ensures you get results even if there's no matching data in the joined tables.
- Subqueries are used to calculate more complex values like transaction counts and holder counts that can't be directly derived from a single table.

</Steps>

## 6. Query Token metadata information

In this SQL query, we retrieve the JSON metadata associated with a specific asset by joining multiple tables and applying filters.

```sql
SELECT tm.json
FROM ma_tx_mint mtm
JOIN tx_metadata tm ON tm.tx_id = mtm.tx_id
JOIN multi_asset ma ON ma.id = mtm.ident
WHERE
    ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'
    AND tm.key = 721
ORDER BY
    mtm.id DESC
LIMIT 1
```

<details>
<summary>
Expected results format
</summary>

```json
{
   "698a6ea0ca99f315034072af31eaac6ec11fe8558d3f48e9775aab9d":{
      "tDRIP":{
         "image":"ipfs://QmfUKSqkaJ8WNuvPzuYsTVZ8aDht3GGKKuzxrhi6S2orNw",
         "name":"tDRIP",
         "mediaType":"image/png",
         "attributes":{
            "publisher":[
               "zeronin ❤️ Memecoin (@Contactdrip) on X ",
               "https://dripdropz.io"
            ]
         }
      }
   }
```

</details>

🔎 Here's a breakdown of how this query works:

<Steps>
### Select JSON Metadata:

```sql
SELECT tm.json
```

This part of the query specifies that we want to retrieve the `json` column from the [tx_metadata](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_metadata) table.

### From ma_tx_mint Table with Joins

```sql
FROM ma_tx_mint mtm
JOIN tx_metadata tm ON tm.tx_id = mtm.tx_id
JOIN multi_asset ma ON ma.id = mtm.ident
```

The data is being retrieved from the [ma_tx_mint](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_mint) table, aliased as `mtm`.

The query joins the [tx_metadata](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_metadata) table `tm`, using the `tx_id` (transaction id) column. The [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) table, alised `ma`, is joined with the `indent` column. using `ma.id = mtm.ident`.

### Filter by Fingerprint and Metadata Key

```sql
WHERE
    ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'
    AND tm.key = 721
```

This condition filters the rows to include only those where the `ma.fingerprint` matches our specific native asset id `asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm`. `tm.key = 721` is referring to `721` which is the metatdata standard for NFTs on Cardano. 

### Order and Limit the Results

```sql
ORDER BY
    mtm.id DESC
LIMIT 1
```

The results are ordered by `mtm.id` in descending order, which means the most recent entry comes first. The `LIMIT 1` clause ensures that only the most recent entry is returned.

### Conclusion
The query retrieves the JSON metadata for a specific asset by:

- Joining the [ma_tx_mint](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#ma_tx_mint), [tx_metadata](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_metadata), and [multi_asset](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#multi_asset) tables from Cardano's database schema.
- Filtering by the asset's fingerprint and extract the JSON metadata associated with the minting transaction, specifically the metadata related to the NFT standard (721). This metadata contains details about the NFT's name, image, policy ID, etc.
- Ordering by the most recent minting transaction and limiting the result to one.

</Steps>

Now that you understood about metadata and have a list of all the assets, you may want to gather more details about a specific collection. This could include information such as the policy ID of the collection, the creation date, the number of assets minted, the number of owners, number of transactions in the last 24 hours, and any unique attributes associated with it.

## 7. Query Active Stake Pools

[Staking](https://cardano.org/stake-pool-delegation/) is a big part of the Cardano ecosystem. To get started, the first step is to identify the active stake pools. Our next SQL query retrieves information about Cardano staking pools, focusing on the pool's ID, name, pool hash, ticker symbols, number of lifetime blocks and creation date. 🔎 Let's take a look at the query which gathers information about these Pools:

```sql
SELECT ph.id,
    po.pool_name as pool_name,
    po.ticker_name as pool_ticker,
    pu.margin as margin,
    ltb.lifetime_blocks as lifetime_blocks
FROM
    pool_hash ph
LEFT JOIN pool_offline_data po ON
    ph.id = po.pool_id
    AND (po.id IS NULL
        OR po.id = (SELECT MAX(po2.id)
                    FROM pool_offline_data po2
                    WHERE po2.pool_id = ph.id))
LEFT JOIN pool_update pu ON
    ph.id = pu.hash_id
    AND pu.id = (SELECT MAX(pu2.id)
                 FROM pool_update pu2
                 WHERE pu2.hash_id = ph.id)
LEFT JOIN (
    SELECT ph.id AS poolId, COUNT(bk.id) AS lifetime_blocks
    FROM pool_hash ph
    JOIN slot_leader sl ON sl.pool_hash_id = ph.id
    JOIN block bk ON bk.slot_leader_id = sl.id
    GROUP BY ph.id
) AS ltb ON ltb.poolId = ph.id;
```

<details>
<summary>
Expected results format
</summary>

```sql

     id   |      pool_name	            |  pool_ticker |      creation_date 
----------+---------------------------------+--------------+-------------------------- 
     4    |      ANGEL stake pool	    |     ANGEL    |  2022-10-20 21:21:59.000
     .    |      ................	    |     .....    |  .................
           
(Note: full results trimmed for readability)
```

</details>


🔎 Here's a breakdown of what the query does:

<Steps>
### Select Specific Columns

In order to gather information about staking pools, the query focuses on:

- Pool ID `ph.id`, the unique identifier for each staking pool.
- Pool Name `pool_name`, the human-readable name of the pool.
- Ticker `pool_ticker`, an abbreviation of the pool.
- Margin `margin`, the percentage of rewards the pool operator keeps as a fee.
- Lifetime Blocks `lifetime_blocks`, the total number of blocks this pool has successfully minted throughout its existence.

### Tables Involved

The query traverses several tables (aliases are in brackets):

- [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash) (ph) stores the unique hash identifiers for each pool.
- [pool_offline_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_offline_data) (po) contains additional information about the pool, such as its name and ticker.
- [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update) (pu) tracks updates to pool parameters, including the margin.
- [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader) (sl) records which pool was the leader for each slot.
- [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block) (bk) stores data about each block produced on the blockchain.

### Main Query (SELECT...FROM)

The query selects the desired columns from the [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash) table.

### LEFT JOIN with pool_offline_data

- This join adds information from the [pool_offline_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_offline_data) table.
- The `ON` condition ensures it only joins the most recent entry for each pool (if any exist).
- The `OR po.id IS NULL` handles the case where a pool doesn't have any offline data.

### LEFT JOIN with pool_update

- This join adds information from the [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update) table.
- The `ON` condition ensures it only joins the most recent update for each pool (if any exist).

### Subquery (ltb)

- This nested query calculates the `lifetime_blocks` for each pool.
- It joins [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash), [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader), and [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block) tables to track which blocks were minted by each pool.
- It groups the results by `pool_hash.id` and counts the number of blocks.

### LEFT JOIN with Subquery (ltb)

The main query joins with the `ltb` subquery to include the calculated `lifetime_blocks` for each pool.

### Conclusion 

- LEFT JOINs ensure that all pool hashes are included in the results, even if they don't have corresponding data in the [pool_offline_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_offline_data) or [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update) tables.
- The nested subquery is essential for calculating the `lifetime_blocks` metric, which requires aggregating data across multiple tables.
- MAX(id) conditions in the `ON` clauses are used to select only the most recent entries from the [[pool_offline_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_offline_data) and [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update) tables for each pool.

</Steps>

### 7.2 List Active Stake Pools

In this addtional query, we include a `WHERE` condition to remove the retired pools:

```sql
select ph.id ,
				COALESCE(po.pool_name, ph."view") as pool_name,
				po.ticker_name as pool_ticker,
				b."time" AS creation_date,
				ROW_NUMBER() OVER (ORDER BY ph.id ASC) 
			FROM
				pool_hash ph
			LEFT JOIN pool_offline_data po on
				ph.id = po.pool_id
				and (po.id is null
					or po.id = (SELECT max(po2.id)
								FROM pool_offline_data po2
								WHERE po2.pool_id = ph.id))
			LEFT JOIN pool_update pu on
				ph.id = pu.hash_id
				and pu.id = (SELECT	min(pu2.id)
								FROM pool_update pu2
								WHERE pu2.hash_id = ph.id)
			LEFT JOIN tx ON tx.id = pu.registered_tx_id 
			LEFT JOIN block b ON tx.block_id = b.id 
			WHERE ph.id NOT IN (SELECT pr.hash_id
						        FROM pool_retire pr
						        LEFT JOIN pool_update pu on	pr.hash_id = pu.hash_id
						        LEFT JOIN pool_hash ph ON ph.id = pr.hash_id
						        GROUP BY pr.hash_id, pu.cert_index, pr.cert_index
						        HAVING (max(pu.registered_tx_id) < max(pr.announced_tx_id))
						        	OR ((max(pu.registered_tx_id) = max(pr.announced_tx_id)) AND (max(pu.cert_index) < max(pr.cert_index)))
						    	)
```

<details>
<summary>
Expected results format
</summary>

```sql

     id   |      pool_name	            |  pool_ticker |      creation_date 
----------+---------------------------------+--------------+-------------------------- 
     5    |      CanadaStakes    	    |     CAN1     |  2022-10-20 21:30:58.000
     6    |      SION stake pool	    |     SION     |  2022-10-20 21:35:52.000
     .    |      ................	    |     .....    |  .................
           
(Note: full results trimmed for readability)
```

</details>

The next query will provide users with detailed information about specific stake pools. This will help them make informed decisions when selecting a pool to delegate their ADA. 

## 8. Query Stake Pool detailed information 

This query retrieves detailed information about a specific staking pool, including its name, ticker, identifier, hash, fixed cost, margin, declared pledge, total lifetime blocks produced, and associated stake account address. To keep things simple, we will use pool ID `pool1j20l32n8un5gce4adk44n9zks8cdvnk3amgursud847cwnpgeg4`

```sql
SELECT 

	ph.id ,
	po.pool_name as pool_name,
	po.ticker_name as pool_ticker,
	ph.view as pool_id,
	ph.hash_raw AS pool_hash,
	pu.fixed_cost AS fixed_cost,
	pu.margin AS margin,
	pu.pledge AS declared_pledge,
	ltb.lifetime_blocks as lifetime_blocks,
	sa.view AS stake_account

FROM
	pool_hash ph

LEFT JOIN pool_offline_data po on
	ph.id = po.pool_id
	and (po.id is null
		or po.id = (SELECT max(po2.id)
					FROM pool_offline_data po2
					WHERE po2.pool_id = ph.id))

LEFT JOIN pool_update pu on
	ph.id = pu.hash_id

	and pu.id = (SELECT max(pu2.id)
					FROM pool_update pu2
					WHERE pu2.hash_id = ph.id)


LEFT JOIN stake_address sa ON pu.reward_addr_id = sa.id

LEFT JOIN (	SELECT ph.id AS poolId, count(bk.id) AS lifetime_blocks
       	FROM pool_hash ph
	        JOIN slot_leader sl ON sl.pool_hash_id = ph.id
	        JOIN block bk ON bk.slot_leader_id = sl.id
	        GROUP BY ph.id	
			) as ltb
	on ltb.poolId = ph.id

WHERE  ph."view" = 'pool1j20l32n8un5gce4adk44n9zks8cdvnk3amgursud847cwnpgeg4'
```

<details>
<summary>
Expected results format
</summary>

```sql

     id   |  pool_name |  pool_ticker |            pool_id                                       |       pool_hash                                               | fixed_cost  |margin | declared_pledge | lifetime_blocks | stake_account 
----------+------------+--------------+----------------------------------------------------------+---------------------------------------------------------------+-------------+-------+-----------------+-----------------+------------------------------------------------------------------
    463   |  clrPool   |   CLRPL      | pool1j20l32n8un5gce4adk44n9zks8cdvnk3amgursud847cwnpgeg4 | 929ff8aa67e4e88c66bd6dab59945681f0d64ed1eed1c1c38d3d7d87      | 170,000,000 |  0.1  |  100,000        |                 | stake_test1uz48zjhv772tacqt93qp0f4425ly0mc44rrgerqhsca4azctyp6hw 

(1 rows)
```

</details>

### 8.1 Query explained 

In this query we retrieve data from tables [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash), [pool_offline_data](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_offline_data), [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update), [stake_address](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#stake_address) for `Pool name`, `Pool Ticker`, `Pool ID`, `Pool Hash`, `Fixed cost`, `Margin`, `Declared pledge`. `Lifetime blocks` data is the total number of blocks that a stake pool has successfully validated since its creation (joining [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block), [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader), [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash)). Stake account data is retrieved from the [stake_address](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#stake_address) table with `id` mapping to `reward_addr_id` from the [pool_update](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_update) table.

### 8.2 Find out who owned the stake pool 

If you would like to know then the Stake Pool owner account, you could run the following query:

```sql
SELECT
	sa."view" AS owner_account
FROM
	pool_hash ph
JOIN pool_update pu ON
	ph.id = pu.hash_id
	AND pu.id = (SELECT MAX(pu2.id) FROM pool_update pu2 WHERE ph.id = pu2.hash_id)
JOIN pool_owner po ON
	pu.id = po.pool_update_id
JOIN stake_address sa ON
	po.addr_id = sa.id
WHERE
	ph."view" = 'pool1j20l32n8un5gce4adk44n9zks8cdvnk3amgursud847cwnpgeg4'
```

<details>
<summary>
Expected results format
</summary>

```sql

     owner_account
--------------------------------------------------------------------
  stake_test1uz48zjhv772tacqt93qp0f4425ly0mc44rrgerqhsca4azctyp6hw
  stake_test1uz00vukcxsleerg97cpa8fk69pryjsa0f0l57gjl60f78ussjymak

(2 rows)
```

</details>


### 8.3 List of delegators 

If you are trying to obtain a list of delegators for a specific pool, then you could run the following query:

```sql
SELECT
	sa.id AS stakeAddressId,
	sa.view AS delegator_address
FROM stake_address sa
WHERE sa.id IN (
	SELECT dg1.addr_id
	FROM delegation dg1
	JOIN pool_hash ph ON dg1.pool_hash_id = ph.id
	WHERE ph.view = 'pool1j20l32n8un5gce4adk44n9zks8cdvnk3amgursud847cwnpgeg4'
	AND NOT EXISTS (
		SELECT TRUE
		FROM delegation dg2
		WHERE dg2.addr_id = dg1.addr_id
		AND dg2.tx_id > dg1.tx_id
	)
	AND NOT EXISTS (
		SELECT TRUE
		FROM stake_deregistration sd
		WHERE sd.addr_id = dg1.addr_id
		AND sd.tx_id > dg1.tx_id
	)
)
```

<details>
<summary>
Expected results format
</summary>

```sql

     stakeaddressid   |  delegator_address                                      
----------------------+-----------------------------------------------------------
     10,497	      | stake_test1uzhl7a0df7v82xlm8yt06h9zjqlkmu636grf8g63h6e0q0sxt5gz4 
     145,345          | stake_test1uz48zjhv772tacqt93qp0f4425ly0mc44rrgerqhsca4azctyp6hw

(2 rows)
```

</details>

The query finds delegators who are currently associated with the given pool and have not moved their delegation or deregistered after their most recent record of delegation to that pool. This helps in identifying active delegators who have not changed their stake status recently.

## 9. Query a stake pool's lifetime blocks

The "Lifetime Blocks" of a stake pool refers to the total number of blocks that the stake pool has successfully produced over its entire operational history. This metric provides insight into the pool's performance and reliability, reflecting its ability to contribute to the Cardano blockchain by creating blocks. Here is how you can fetch this information. 


```sql
SELECT ph.view , bk.hash as block_hash, bk.epoch_no, ROW_NUMBER() OVER (ORDER BY bk.epoch_no)
            FROM pool_hash ph
            JOIN slot_leader sl ON sl.pool_hash_id = ph.id
            JOIN block bk ON bk.slot_leader_id = sl.id
            WHERE ph.view = 'pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38'
```

<details>
<summary>
Expected results format
</summary>

```sql

     view                                                |      block_hash		                                    |  epoch_no |  epoch_no 
---------------------------------------------------------+------------------------------------------------------------------+-----------+---------- 
pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38 |  0244d69ef4149a38b4e717c64ff31af199b4e48d187766a7ef2163ac980ddb49|   121     |   1              
pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38 |  79bada15eb17f192e3bca7d57d8137d57f724f5ea937581bfdecae6af5ba6701|   121	|   2
pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38 |  47fc8af17dd11b0d8ea83ce61548f8309df11585a4ef2de622a2538b84350d6a|   121	|   3
	...................				 |  			..................			    |   ...	|   ..

(Note: full results trimmed for readability)
```

</details>

In this SQL query, we retrieve information about blocks associated with a specific pool hash by joining multiple tables. Let's take a closer look at what the query does. 🔎  

<Steps>

### 'SELECT'ing the right info

`SELECT` clause retrieves the following data:

- `ph.view` selects the unique identifier, or 'view', of the stake pool.
- `bk.hash as block_hash` selects the unique hash identifier of each block.
- `bk.epoch_no` selects the epoch number in which the block was created.
- `ROW_NUMBER() OVER (ORDER BY bk.epoch_no)` assigns a sequential row number to each block, starting from 1, and then ordered chronologically by epoch number. This tracks the order in which the stake pool created blocks over time.

### FROM pool_hash ph
- Looks in the table [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash), which stores information about stake pools, and assigns it the alias `ph`.

### JOIN slot_leader sl ON sl.pool_hash_id = ph.id
Joins the [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash) table with the [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader) table. The connection is made based on the matching `id` from [pool_hash](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#pool_hash) and `pool_hash_id` from [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader). The [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader) table provides us with information about which stake pool was selected to lead a particular slot and potentially create a block.

### JOIN block bk ON bk.slot_leader_id = sl.id
Joins the result of the previous join with the [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block) table. The connection is based on matching the `id` from [slot_leader](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#slot_leader) with `slot_leader_id` from [block](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#block). The block table stores detailed information about each block on the blockchain.

### WHERE ph.view = 'pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38'
This `WHERE' clause restricts the results to only show blocks created by the stake pool with the specific view id we give the query. 

### Conclusion

The query returns a result set containing:
- The stake pool's view id.
- The unique hash of each block created by the stake pool.
- The epoch number of each block.
- A row number indicating the chronological order of block creation.

🔎  Remember you can always verify any result using the [Cardano Explorer](https://preprod.beta.explorer.cardano.org/en/pool/pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38?tab=epochs&page=1&size=50) 🎯 

![lifetimeblocks](/images/lifetime_blocks_of_stake_pool.png)

</Steps>

## 10. List the current dReps

Another important feature Cardano Blockchain implements is Governnace. This query provides a list of dReps currently registered on the system and additional information including:

- dRep ID
- tx_id of the registration
- cert index
- type 
- deposit
- hash of the pool which we it is delegating to
- credential type
- anchor URL (if available)
- anchor hash (if available)
- dRep status (active / inactive)
- Registration date 
- epoch
- block
- slot
- number of delegators (not sure if is possible to get this inf as of now)

This information helps you understand who is voting on proposals and shaping the future of the Cardano ecosystem. Note that we are using the *Sanchonet* network for this query (it is the same database schema as before). 

```sql
select
    dr.drep_id AS drepId,
    dr.drep_hash AS drepHash,
    dr.tx_hash AS tx_id,
    dr.cert_index AS cert_index,
    dr."type" AS "type",
    dr.deposit AS deposit,
    dr.cred_type AS credential_type,
    dr.anchor_url AS anchor_url,
    dr.anchor_hash AS anchor_hash,
    CASE
	    WHEN COALESCE(vp.epoch, 0)
	    	+ (SELECT COALESCE(ep.drep_activity, 0) FROM epoch_param ep ORDER BY ep.epoch_no DESC LIMIT 1) 
	    	< (SELECT COALESCE(ep.epoch_no, 0) FROM epoch_param ep ORDER BY ep.epoch_no DESC LIMIT 1)
	    	THEN 'INACTIVE'
	    WHEN dr."type" = 'UNREG_DREP_CERT'
	    	THEN 'RETIRED'
	    ELSE 'ACTIVE'
	END AS dRep_status,
    to_timestamp(sub2.block_time) at TIME zone 'UTC' as registration_date,
    dr.epoch AS epoch,
	dr.block AS block,
	dr.slot AS slot,
    coalesce (sub3.delegators_count, 0) as number_of_delegators
FROM drep_registration dr
JOIN (SELECT
	        max(slot) AS max_slot,
	        dr.drep_hash
	  FROM drep_registration dr
	  GROUP BY dr.drep_hash    
	 ) AS sub1 
ON  dr.drep_hash = sub1.drep_hash
    and dr.slot = sub1.max_slot
JOIN (	SELECT
	        max(block_time) as block_time ,
	        dr.drep_hash
	    FROM drep_registration dr
	    WHERE dr."type" = 'REG_DREP_CERT'
	    GROUP BY dr.drep_hash
		) AS sub2
ON dr.drep_hash = sub2.drep_hash
LEFT JOIN ( SELECT
		        count(DISTINCT(d.address)) as delegators_count,
		        d.drep_hash
		    FROM delegation_vote d
		    WHERE d.drep_hash is not null
		    GROUP BY drep_hash
			) AS sub3
ON dr.drep_hash = sub3.drep_hash
LEFT JOIN (	SELECT voter_hash, max(epoch) AS epoch, max(slot) 
			FROM voting_procedure 
			GROUP BY voter_hash
			) vp ON vp.voter_hash = dr.drep_hash
```

<details>
<summary>
Expected results format
</summary>

```sql

drepid   | drephash| tx_id    | cert_index | type        | deposit | credential_type | anchor_url      | anchor_hash | drep_status | registration_date | epoch | block | slot   | number_of_delegators
---------+---------+----------+------------+-------------+---------+-----------------+-----------------+-------------+-------------+-------------------+-------+-------+--------+--------------------- 
drep1..n | 0ae..d50| 3fd..7a20| 6          |REG_DREP_CERT|500000000| ADDR_KEYHASH    | https://bit..2HL|  1..111     |    INACTIVE |  2024-08-01 16:56 | 413   |1784176|35742397| 0


(Note: full results trimmed for readability)
```

</details>

Let's take a closer look at what the query does. 🔎  

<Steps>

### Main `SELECT` Clause

`SELECT`s various columns from the [drep_registration](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#drep_registration) table (alias `dr`) such as `drep_id`, `drep_hash`, `tx_id`, `cert_index`, `type`, `deposit`, `cred_type`, `anchor_url`, `anchor_hash`, `epoch`, `block`, and `slot`.

### `CASE` Statement for `dRep_status`

Calculates the `dRep_status` based on the following logic:
- `INACTIVE`...If the sum of `vp.epoch` (from the [voting_procedure](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#voting_procedure) table) and the latest `drep_activity` from [epoch_param](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#epoch_param) is less than the latest `epoch_n` from [epoch_param](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#epoch_param). This likely indicates the dRep hasn't been active in recent epochs.
- `RETIRED` If the type in [drep_registration](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#drep_registration) is `UNREG_DREP_CERT`, meaning the dRep has been unregistered.
- `ACTIVE`... otherwise, the dRep is considered active.

### `registration_date` Calculation

Converts the `block_time` (from the [drep_registration](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#drep_registration) table) to a timestamp with UTC timezone.
The subquery `sub2` fetches the maximum `block_time` for each `drep_hash` where the `type` is 'REG_DREP_CERT' (registration certificate).

### `number_of_delegators` Calculation

Uses a `LEFT JOIN` with a subquery `sub3` to count the number of distinct delegators `address` associated with each `drep_hash` in the [delegation_vote](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#delegation_vote) table. `COALESCE` ensures that if there are no delegators, the count is shown as 0.

### Joins and Subqueries

`JOIN with sub1` ensures only the latest registration entry for each `drep_hash` is considered (based on the maximum slot).
`LEFT JOIN` with `sub3` and `vp` brings in the delegators count and latest voting epoch information for each dRep.

</Steps>

## 11. List of "Active Governance Proposals" and number of votes

The next step is to view the list of "Active Governance Proposals." This query shows current proposals and the number of votes each has received. This information helps you understand ongoing governance activities and community support for each proposal. Again, we will use the *Sanchonet* network for this query. 

Specifically, our query will provide us with a list of “Active“ Governance proposals and associate details:

- Proposal tx_id
- Index
- Deposit
- Returned address
- Anchor URL (if available)
- Anchor hash (if available)
- Type (one of the [7 governance actions](https://docs.sanchogov.tools/how-to-use-the-govtool/using-govtool/governance-actions))
- Details
- Epoch
- Slot
- Block
- timestamp 
- Number of yes/no/abstain 

```sql
SELECT 	gap.tx_hash AS tx_id,
		gap.idx AS "index",
		gap.deposit AS deposit,
		gap.return_address AS returned_address,
		gap.anchor_url AS anchor_url,
		gap.anchor_hash AS anchor_hash,
		gap."type" AS "type",
		gap.details AS details,
		gap.epoch AS epoch,
		gap.slot AS slot,
		gap.block AS block,
		gap.update_datetime AS time_stamp,
		(CASE WHEN voting.yes_vote IS NULL THEN 0 ELSE voting.yes_vote END) AS yes_vote,
		(CASE WHEN voting.no_vote IS NULL THEN 0 ELSE voting.no_vote END) AS no_vote,
		(CASE WHEN voting.abstain_vote IS NULL THEN 0 ELSE voting.abstain_vote END) AS abstain_vote
			FROM gov_action_proposal gap
			LEFT JOIN (SELECT 	listVote.gov_action_tx_hash AS gov_action_tx_hash,
						listVote.gov_action_index AS gov_action_index,
						sum(CASE WHEN listVote.vote = 'YES' THEN 1 ELSE 0 END) AS yes_vote,
						sum(CASE WHEN listVote.vote = 'NO' THEN 1 ELSE 0 END) AS no_vote,
						sum(CASE WHEN listVote.vote = 'ABSTAIN' THEN 1 ELSE 0 END) AS abstain_vote
				FROM (	SELECT voter_hash, gov_action_tx_hash, gov_action_index, vote, 
						ROW_NUMBER() OVER (PARTITION BY voter_hash, gov_action_tx_hash, gov_action_index ORDER BY slot DESC) AS rank_slot
				FROM voting_procedure vp 
						) AS listVote
				WHERE rank_slot = 1			
			        GROUP BY listVote.gov_action_tx_hash, listVote.gov_action_index
				) AS voting ON voting.gov_action_tx_hash = gap.tx_hash AND voting.gov_action_index = gap.idx
			WHERE 
				COALESCE(gap.epoch, 0) 
				+ 
				(SELECT COALESCE(ep.gov_action_lifetime, 0) FROM epoch_param ep
					ORDER BY ep.epoch_no DESC LIMIT 1)
				>= 
				(SELECT COALESCE(ep.epoch_no, 0) FROM epoch_param ep
				    ORDER BY ep.epoch_no DESC LIMIT 1)
```

<details>
<summary>
Expected results format
</summary>

```sql

tx_id      | index| deposit        | returned_address     | anchor_url                                | anchor_hash | type                   | details                | epoch | slot       | block     | time_stamp      | yes_vote | no_vote | abstain_vote
-----------+------+----------------+----------------------+-------------------------------------------+-------------+------------------------+------------------------+-------+------------+-----------+-----------------+----------+---------+------------- 
b71b...e3a | 0    | 100,000,000,000| stake_test1up...2r5a | https://thc-room335.com/poolMetaData.json | 6dd6...755  | INFO_ACTION            | {"type": "INFO_ACTION"}| 406   | 35,115,090 | 1,754,277 |2024-08-07 10:07 |     0    |    0    |       0


(Note: full results trimmed for readability)
```

</details>



🔎  Here's a breakdown of what the query does:

<Steps>

### Proposal Information Retrieval 

The primary focus of the query is to fetch data from the [gov_action_proposal](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#gov_action_proposal) table (alias `gap`). This returns details like:

- `tx_hash` ...the unique transaction identifier associated with the proposal.
- `idx` ...an index within the transaction.
- `deposit`, `return_address`, `anchor_url`, `anchor_hash` ...proposal-specific metadata.
- `type`, `details`...the nature of the proposal and additional descriptive text.
- `epoch`, `slot`, `block`...information about when the proposal was made.
- `update_datetime` ...the last time this record was modified in the database.

### Voting Data Aggregation

The subquery aliased as `voting` calculates the `yes_vote`, `no_vote`, and `abstain_vote` counts for each proposal. It does this by checking the [voting_procedure](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#voting_procedure) table, filtering for the latest vote from each voter on each proposal `(using ROW_NUMBER() and rank_slot = 1)`. It then groups the results by gov_action_tx_hash and gov_action_index to get totals per proposal.

### Joining Proposal and Voting Data

A `LEFT JOIN` combines the proposal information with the calculated vote counts. This ensures that even proposals without any votes are included in the output, with their vote counts shown as 0.

### Filtering Active Proposals

The `WHERE` clause filters the results to only include proposals that are still considered "active" based on:
- The proposal's epoch, when it was made.
- The latest `gov_action_lifetime` parameter from the [epoch_param](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#epoch_param) table, ie. how long proposals remain active.
- The latest `epoch_no` from the [epoch_param](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#epoch_param) table, ie. the current epoch.

</Steps>

## 12. Query Smart contract transaction information 

For our final query, we will inspect the details of a specific transaction, namely, the transaction id `52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57`. Note we are not modifying the blockchain in any way, we are just reading data from it. 


🔎  As usual, you can also take a closer look using the [Cardano Explorer](https://beta.explorer.cardano.org/en/transaction/52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57/summary/)


### 12.1 Transaction information

Let's start by retrieving the transaction details:
- transaction hash
- timestamp
- block
- fee
- epoch
- slot
- source address
- destination address
- assets
- amount
- UTXOs used

```sql
SELECT tx_detail.* FROM (
			SELECT 
				'destination_address' AS direction,
				tx.hash AS txhash,
				tx_out.address AS address,
				sa."view" AS stake_address,
				tx_out.value AS ADA_amount,
				ma.name AS asset_name,
				sum(mto.quantity) AS quantity,
				b.time AS time_stamp,
				tx.fee AS transaction_fee,
				b.block_no AS block,
				b.slot_no AS slot,
				b.epoch_no AS epoch,
				NULL AS utxo
		       FROM tx
				LEFT JOIN tx_out ON tx_out.tx_id = tx.id
				LEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id
				LEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id
				LEFT JOIN multi_asset ma ON ma.id = mto.ident
				LEFT JOIN block b ON b.id = tx.block_id
			WHERE
				tx.hash = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
			GROUP BY direction, txhash, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, epoch, utxo
			UNION ALL
			SELECT 
				'source_address' AS direction,
				tx.hash AS txhash,
				tx_out.address AS address,
				sa."view" AS stake_address,
				tx_out.value ADA_amount,
				ma.name AS asset_name,
				sum(mto.quantity) AS quantity,
				b.time AS time_stamp,
				tx.fee AS transaction_fee,
				b.block_no AS block,
				b.slot_no AS slot,
				b.epoch_no AS epoch,
				txin.hash AS utxo
			FROM tx
				LEFT JOIN tx_in ti ON ti.tx_in_id = tx.id
				LEFT JOIN tx_out ON tx_out.tx_id = ti.tx_out_id AND tx_out."index" = ti.tx_out_index 
				LEFT JOIN tx txin ON txin.id = tx_out.tx_id
				LEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id
				LEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id
				LEFT JOIN multi_asset ma ON ma.id = mto.ident
				LEFT JOIN block b ON b.id = tx.block_id
			WHERE
				tx.hash = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
			GROUP BY direction, txhash, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, epoch, utxo
				) AS tx_detail
		ORDER BY tx_detail.direction ASC
```

<details>
<summary>
Expected results format
</summary>

```sql

direction           |  txhash            |  address              | stake_address              |ada_amount|asset_name|quantity|time_stamp	 |tx_fee |block     | slot      |epoch|utxo
--------------------+--------------------+-----------------------+----------------------------+----------+----------+--------+-------------------+------------------+-----------+-----+----------
destination_address | 52385f2dd....ebb57 |addr1q94ga....grqd9dw0d|stake1u9d9...sapektypsmfx9qr|20,000,000|          |        |2024-07-13 15:33:54|395,771|10,568,064|129,318,543| 496 | 	 
source_address      | 52385f2dd....ebb57 |addr1qyvl8....vgsyxh7q9|stake1uxw4...8f43pxkyg5842yn|33,080,297|          |        |2024-07-13 15:33:54|395,771|10,568,064|129,318,543| 496 |9d8...57a


(Note: full results trimmed for readability)
```

</details>

🔎 Let's zoom in to see what the query does step-by-step:

<Steps>

### Overall query structure

To find the information we need, the query focuses on two perspectives:

- **Destination Addresses:** Where did the funds/assets end up?
- **Source Addresses:** Where did the funds/assets come from?

`UNION ALL` combines the results from the two separate `SELECT` statements. Each `SELECT` statement targets one of the perspectives above.

### Destination Addresses, the first `SELECT`

It fetches details about the outputs [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) of the transaction. It then links to other tables to fetch further information such as:
    - Stake address associated with the output
    - Asset names and quantities 
    - Block, slot, and epoch details of the transaction
    - Transaction fee

### Source Addresses, the second `SELECT`

This `SELECT` statement looks back to the inputs [tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_in) of the transaction. It traces the chain of transactions to find the original outputs [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) that were spent as inputs in this transaction. It retrieves similar information as the first `SELECT`, but additionally includes the 'utxo' (unspent transaction output) hash which represents the specific output that was spent.

### Result returned

The two result sets are combined with a `UNION ALL` clause, and the final output is sorted by `direction` so that `destination_address` rows appear before `source_address` rows in the results.

</Steps>

### 12.2 Contracts details 

For this query, we are looking for the Redeemer, datum hash and datum associated with the transaction. 

```sql
SELECT 
	re.script_hash AS scriptHash, 
	txOut.address AS address, 
	re.purpose as purpose,
        encode(rd.bytes, 'hex') as redeemerData, 
        re.unit_mem as redeemerMem, 
        re.unit_steps as redeemerSteps,
        d.hash as datumHash, 
        encode(d.bytes, 'hex') as datum
           FROM tx
           INNER JOIN redeemer re ON re.tx_id = tx.id 
           LEFT JOIN redeemer_data rd ON re.redeemer_data_id = rd.id 
           LEFT JOIN tx_in txIn ON (txIn.redeemer_id = re.id and txIn.tx_in_id = tx.id)
           LEFT JOIN tx_out txOut ON txIn.tx_out_id = txOut.tx_id AND txIn.tx_out_index = txOut.index
           LEFT JOIN datum d ON (txOut.data_hash = d.hash OR txOut.inline_datum_id = d.id)
           WHERE tx.hash = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
```


<details>
<summary>
Expected results format
</summary>

```sql

scripthash    | address      |purpose|redeemerbytes| redeemermem| redeemersteps	 | datumhash         | datumbytes
--------------+--------------+-------+-------------+------------+----------------+-------------------+------------------------
9068...ce138ad|addr1zx...5plm|spend  |d87a80       | 2,463,014  |  689,900,093	 | 3c27703297...1fce | d8799f581c...00ffffffff


(Note: full results trimmed for readability)
```

</details>

🔎 Let's zoom in to see what the query does step-by-step:

Certainly, let's break down what this SQL query accomplishes on the Cardano blockchain.

<Steps>

### Target transaction

`WHERE tx.hash = '...'` filters to the specific transaction we are interested in.

### Redeemer details
`INNER JOIN redeemer re ON re.tx_id = tx.id` ensures we only consider redeemers associated with the target transaction. `re.script_hash`, `re.purpose`, `re.unit_mem`, `re.unit_steps` fetch the script hash the redeemer interacts with, its purpose, memory usage, and computational steps, respectively.

### Redeemer Data
`LEFT JOIN redeemer_data rd ON re.redeemer_data_id = rd.id` brings in redeemer data if it exists. `encode(rd.bytes, 'hex') as redeemerData` converts the raw redeemer data into a human-readable hexadecimal format.

### Transaction input and output JOIN
`LEFT JOIN tx_in txIn ON ...` joins the transaction input that triggered the redeemer to the transaction itself. `LEFT JOIN tx_out txOut ON ...` links this input with the specific transaction output it spends from. `txOut.address` extracts the address of the output being spent.

### Datum information 
`LEFT JOIN datum d ON ...` attempts to find a datum linked to the spent output, either through a hash reference or an inline datum.
`d.hash` and `encode(d.bytes, 'hex') as datum` provide the datum hash and its hexadecimal representation.

### Output 

The query will produce a result set containing:

- `scriptHash` ...the script hash the redeemer interacts with.
- `address`...the address of the UTxO spent by the transaction input.
- `purpose`...the purpose of the redeemer 
- `redeemerData`...the Hex-encoded redeemer data (if present).
- `redeemerMem` & `redeemerSteps`...the redeemer's memory & computational step usage.
- `datumHash`...the hash of the datum associated with the spent output.
- `datum` ...the hex-encoded datum content (if present).

</Steps>

<Callout type="info" emoji="💡">
Remember you can also review the results in any Cardano explorer.  The *Cardano Developer Portal* has compiled a [list](https://developers.cardano.org/showcase/?tags=explorer) in their 'Showcase' section. For example, you can review review the results of Queries 12.1 and 12.2 at [this link](https://cardanoscan.io/transaction/52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57?tab=utxo) 🔎 
</Callout>

### 12.3 Collateral input & output 

This query retrieves information about the inputs and outputs associated with our transaction, identified by its hash `52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57`. The inputs and outputs are categorized in the results in the 'collateral' column.

```sql
	   SELECT 
		'input' AS collateral,
	       	txOut.address AS address, 
             	txOut.value AS value,
             	txOut.index AS index
           FROM unconsume_tx_in cti 
           INNER JOIN tx_out txOut on txOut.tx_id = cti.tx_out_id and txOut.index = cti.tx_out_index 
           LEFT JOIN tx ON cti.tx_in_id = tx.id 
           JOIN tx txin ON cti.tx_out_id = txin.id 
           WHERE 
		tx.hash  = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
           
           UNION
          
           SELECT 
		   'output' AS collateral,
	           failedTxOut.address AS address, 
	           failedTxOut.value AS value,
	           failedTxOut.index AS index
           FROM failed_tx_out failedTxOut 
           INNER JOIN tx ON failedTxOut.tx_id = tx.id
           WHERE tx.hash = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
```

<details>
<summary>
Expected results format
</summary>

```sql

collateral | address      											     |value       |index
-----------+---------------------------------------------------------------------------------------------------------+------------+-----
input      | addr1qyvl8lmwpfq7pahuadpjwul9xlj7c0atr5hvu4r3cjsjlfua276aqezvwjsfucvq76welxmytfyt7ug5835wntzzdvgsyxh7q9 | 33,080,297 | 0
output     | addr1qyvl8lmwpfq7pahuadpjwul9xlj7c0atr5hvu4r3cjsjlfua276aqezvwjsfucvq76welxmytfyt7ug5835wntzzdvgsyxh7q9 | 32,486,640 | 5

```

</details>

🔎 Let's zoom in to see what the query does step-by-step:

<Steps>

### First `SELECT`

The `FROM unconsume_tx_in cti` clause starts by looking at unspent transaction outputs (UTXOs) that have been used as inputs in some other transaction. The `INNER JOIN tx_out txOut ...` joins with the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table to get details about these UTXOs, ie. address, value, index within the transaction. 

The `LEFT JOIN tx ON ...` attempts to join with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table to see if there's a transaction where this UTXO was used as an input.

The `JOIN tx txin ON ...` clause also joins with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table again (alias `txin`) to get details about the transaction where this UTXO was originally created as an output.

The `WHERE tx.hash = ...` clause filters the results to only include UTXOs that were used as inputs in the specific transaction we specified. The `'input' AS collateral` clause labels these results as 'input' in the `collateral` column.

### Second `SELECT`

The `FROM failed_tx_out failedTxOut` looks at outputs from transactions that failed. The `INNER JOIN tx ON ...` clause joins with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table to get details about the failed transaction.

The `WHERE tx.hash = ...` clause filters the results to only include outputs from the specific failed transaction we're interested in. The `'output' AS collateral` clause labels these results as 'output' in the `collateral` column.

### `UNION`

The `UNION` clause combines the results from the two parts into a single result set:
- `collateral` indicates whether the row represents a transaction input or an output
- `address` ...ie, the address associated with the input or output
- `value` is the amount of ADA (or other assets) associated with the input or output
- `index` tells us the position of the input or output within its transaction

</Steps>

### 12.4 Reference input and contract reference

Our final query aims to retrieve details about the outputs (UTXOs) that were **spent** as inputs in our specific transaction, identified by its hash `52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57`. 

```sql
	  SELECT 
  		txOut.address as address,
     		tx.hash as txHash, 
      		txOut.value as value, 
      		r.tx_out_index as index
           FROM reference_tx_in r
           JOIN tx_out txOut ON r.tx_out_id = txOut.tx_id AND txOut.index = r.tx_out_index
           JOIN tx ON txOut.tx_id = tx.id 
	   JOIN tx txin ON txin.id = r.tx_in_id 
           WHERE 
		txin.hash = '52385f2dd6b69eb035474b529249afda132cde54f54c727842393edc51bebb57'
```

<details>
<summary>
Expected results format
</summary>

```sql

address 												| txhash      		|value       |index
--------------------------------------------------------------------------------------------------------+-----------------------+------------+-----
addr1zxgx3far7qygq0k6epa0zcvcvrevmn0ypsnfsue94nsn3tvpw288a4x0xf8pxgcntelxmyclq83s0ykeehchz2wtspks905plm	| 9a3245....b0fc1d06f5b | 40,000,000 | 0

(Note:  results abbreviated for readability)

```

</details>

🔎 Let's zoom in to see what the query does step-by-step:

<Steps>

### Query structure

The `FROM reference_tx_in r` starts by looking at the [reference_tx_in](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#reference_tx_in) table, which stores information about transaction inputs and the UTXOs they reference.

`JOIN tx_out txOut ON ...`  joins with the [tx_out](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx_out) table to get details about these UTXOs, ie. address, value, index within the transaction. 

`JOIN tx ON txOut.tx_id = tx.id` joins with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table to get information about the transaction where these UTXOs were created as outputs.

`JOIN tx txin ON txin.id = r.tx_in_id` joins with the [tx](https://github.com/cardano-foundation/cf-ledger-sync/blob/main/docs/pages/schema.md#tx) table again (aliase `txin`) to get details about the transaction where these UTXOs were spent as inputs.

The `WHERE txin.hash = ...` clause filters the results to only include UTXOs that were spent as inputs in the specific transaction we're interested in.

### Results

- `address` is the address associated with the spent UTXO
- `txHash` is the hash of the transaction where this UTXO was created as an output
- `value` is the amount of ADA (or other assets) associated with the spent UTXO
- `index` is the position of the UTXO within the transaction where it was created

</Steps>
