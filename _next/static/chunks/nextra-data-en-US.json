{"/about":{"title":"About","data":{"":"//TODO"}},"/applications/ledger_sync_app":{"title":"Ledger Sync App","data":{"":"This is the main indexer application that reads data from the Cardano blockchain and writes to a PostgreSQL database."}},"/applications/streamer_app":{"title":"Ledger Sync Streamer","data":{"":"Ledger Sync Streamer app reads data from a Cardano node and publishes blockchain data to a messaging middleware like Kafka or RabbitMQ.\nIt publishes blockchain data in the form of events. There are various types of events that can be published by the streamer app, but you can configure which events you want to publish.As this app uses Spring Cloud Stream, it can support other supported binders in Spring Cloud Stream with some minor changes.\n(https://spring.io/projects/spring-cloud-stream)","pre-requisites#Pre-requisites":"To run the streamer app, you need to have following components:\nCardano Node or connect to a remote Cardano node\nDatabase (PostgreSQL, MySQL, H2) : To store cursor/checkpoint data\nMessaging middleware (Kafka, RabbitMQ) : To publish events","events#Events":"Events are published as JSON messages, and each event contains two fields:\nmetadata: Contains metadata about the event, such as block number, slot number, era, etc.\n<payload>: Contains the actual data of the event.\nThe supported events are:\nblockEvent - Shelley and Post Shelley Blocks data (Includes everything transactions, witnesses..)\nrollbackEvent - Rollback event with rollback point\nbyronMainBlockEvent - Byron Main Block data\nbyronEbBlockEvent - Byron Epoch Boundary Block data\nblockHeaderEvent - Shelley and Post Shelley Block Header data\ngenesisBlockEvent - Genesis Block data\ncertificateEvent - Certificate data in a block\ntransactionEvent - Transaction data. One transactionEvent with all transactions in a block\nauxDataEvent - Auxiliary data in a block\nmintBurnEvent - Mint and Burn data in a block\nscriptEvent - Script data of all transactions in a block","channels#Channels":"By default, the events are published to default channels, but you also have the flexibility to\nconfigure custom channels as needed.\nblockEvent - blockTopic\nrollbackEvent - rollbackTopic\nbyronMainBlockEvent - byronMainBlockTopic\nbyronEbBlockEvent - byronEbBlockTopic\nblockHeaderEvent - blockHeaderTopic\ngenesisBlockEvent - genesisBlockTopic\ncertificateEvent - certificateTopic\ntransactionEvent - transactionTopic\nauxDataEvent - auxDataTopic\nmintBurnEvent - mintBurnTopic\nscriptEvent - scriptTopic\nThe default channel can be changed by changing the following properties in application.properties file or Docker environment file.\nspring.cloud.stream.bindings.<event_name>-out-0.destination=<topic_name>\nFor more details on different configuration options, please refer to the application-kafka.properties or application-rabbit.properties file in config folder.","how-to-run-jar-file#How to run (Jar file)":"To run the streamer app, you need Java 21 or a newer version.\nAfter building the project, you can execute the JAR file using the following commands:To run with Kafka binder:\nGo to top level directory of the project.\nEdit the config/application-kafka.properties file and provide required information for Cardano node, datasource, Kafka.\nRun the streamer jar file with kafka profile.\njava -jar -Dspring.profiles.active=kafka streamer-app/build/libs/ledger-sync-streamer-app-<version>.jar\nTo run with Rabbit binder:\nGo to top level directory of the project.\nEdit the config/application-rabbit.properties file and provide required information for cardano node, datasource, RabbitMQ.\nRun the streamer jar file with rabbit profile.\njava -jar -Dspring.profiles.active=rabbit streamer-app/build/libs/ledger-sync-streamer-app-<version>.jar\nImportant: If you want to start the sync again from start, you need to delete the schema from the database and start the sync again.","how-to-run-docker#How to run (Docker)":"There are two Docker compose files available to run the streamer app with Kafka or RabbitMQ in the streamer-app folder.To run with Kafka :\ndocker compose -f docker-compose-kafka.yml up\nTo run with RabbitMQ :\ndocker compose -f docker-compose-rabbit.yml up\nImportant: If you want to start the sync again from start, you need to delete the schema from the database and start the sync again.","to-start-sync-from-a-specific-points#To start sync from a specific points":"Set the following properties in config file to start the sync from a specific point:\nstore.cardano.sync-start-slot=<absolute_slot>\nstore.cardano.sync-start-blockhash=<block_hash>\nFor Docker environment, you can set the following environment variables:\nSTORE_CARDANO_SYNC-START-SLOT=<absolute_slot>\nSTORE_CARDANO_SYNC-START-BLOCKHASH=<block_hash>","kafka-configuration#Kafka Configuration":"The default message size in Kafka is 1 MB. To accommodate larger JSON payloads, which can exceed 1 MB in the case of some blocks, you will need to increase this value.\nKAFKA_MESSAGE_MAX_BYTES=20000000"}},"/build_run":{"title":"How to Run","data":{"pre-requisites#Pre-requisites":"Java 21\nCardano Node or connect to a remote Cardano node\nPostgreSQL DB","build-jar#Build Jar":"./gradlew clean build -x test","update-databse-details#Update databse details":"Edit config/application.properties to add datasource url, username & password.\nspring.datasource.url=jdbc:postgresql://localhost:5432/<db>\nspring.datasource.username=user\nspring.datasource.password=\nRun\njava -jar application/build/libs/ledger-sync-application-<version>-SNAPSHOT.jar","docker-build--run#Docker Build & Run":"Build the jar file first\n./gradlew clean build -x test\nBuild docker image\ndocker build  --target ledger-sync -t cardanofoundation/ledger-sync:<version> .","docker-run#Docker Run":"Copy env.example to envEdit env file with database and network details\ndocker run -p 8080:8080 --env-file env cardanofoundation/ledger-sync:<version>"}},"/design":{"title":"Design","data":{"design#Design":"This section describes the design of the Ledger Sync application. Ledger Sync uses the Yaci Store library to interact with the Cardano blockchain.","high-level-design#High Level Design":"","data-flow-diagram#Data Flow Diagram":"","components#Components":""}},"/docker":{"title":"Running Ledger Sync with Docker Compose","data":{"":"This guide explains how to run the LedgerSync main indexer application using Docker Compose.\nYou will find the necessary Docker Compose files in the docker directory of the repository.","prerequisites#Prerequisites":"Ensure that Docker and Docker Compose are installed on your system.","directory-structure#Directory Structure":"The docker directory contains the following Docker Compose files:\ndocker-compose-monolith.yml: Combines both the LedgerSync application and PostgreSQL.\nmain-app-compose.yml: For running the LedgerSync application only, connecting to an external PostgreSQL database.\npostgres-compose.yml: For configuring and running the PostgreSQL database.","environment-variable-configuration#Environment Variable Configuration":"You can configure the environment variables using one of the following methods:\n.env file: Place your environment variables in the .env file located in the docker directory.\napplication.properties file: Update the application.properties file in the docker directory. This file is mounted as a volume in the Docker container, and the application reads the environment variables from it.\nNote: If you set a variable in the application.properties file, ensure that the same variable is removed from the Docker Compose YAML file or .env file. The value from the application.properties file will be overridden if the variable is present in multiple places.","variable-naming-convention#Variable Naming Convention":"In application.properties, use . as a separator (e.g., spring.datasource.url).\nIn Docker Compose YAML files or the .env file, use _ as a separator and uppercase letters (e.g., SPRING_DATASOURCE_URL).","1-running-ledgersync-with-postgresql#1. Running LedgerSync with PostgreSQL":"To run the Ledger Sync main indexer application with an integrated PostgreSQL database, use the docker-compose-monolith.yml file.\nThis file includes configurations from both main-app-compose.yml and postgres-compose.yml.","command#Command":"docker-compose -f docker-compose-monolith.yml up\nThis command will start both the LedgerSync application and PostgreSQL database.","2-running-ledgersync-with-external-postgresql#2. Running LedgerSync with External PostgreSQL":"If you prefer to connect LedgerSync to an external PostgreSQL database, use the main-app-compose.yml file. You will need to configure the PostgreSQL connection details in the .env file or application.properties file.","environment-variables#Environment Variables":"In the .env file:\nSPRING_DATASOURCE_URL=jdbc:postgresql://<host>:<port>/<database>?currentSchema=<schema>\nSPRING_DATASOURCE_USERNAME=<username>\nSPRING_DATASOURCE_PASSWORD=<password>\nIn the application.properties file:\nspring.datasource.url=jdbc:postgresql://<host>:<port>/<database>?currentSchema=<schema>\nspring.datasource.username=<username>\nspring.datasource.password=<password>\nMake sure to remove these variables from the .env file or Docker Compose YAML if they are set in application.properties.","command-1#Command":"docker-compose -f main-app-compose.yml up\nThis command will start the LedgerSync application and connect it to your external PostgreSQL database.","changing-the-network#Changing the Network":"By default, LedgerSync is configured to connect to the Cardano mainnet. However, you can easily change the network to connect\nto other Cardano networks such as the preprod or preview or sanchonet by modifying the network-related environment variables.","configuration-steps#Configuration Steps":"Modify the .env file:\nUpdate the network-related environment variables in the .env file. For example, to connect to the Cardano preprod:\nNETWORK=preprod\nSTORE_CARDANO_HOST=preprod-node.world.dev.cardano.org\nSTORE_CARDANO_PORT=30000\nSTORE_CARDANO_PROTOCOLMAGIC=1\nUpdate application.properties:\nAlternatively, if you're using application.properties for configuration, update the relevant properties as follows:\nnetwork=preprod\nstore.cardano.host=preprod-node.world.dev.cardano.org\nstore.cardano.port=30000\nstore.cardano.protocolMagic=1\nNote: Valid networks :  mainnet, preprod, preview,sanchonet","configuring-n2c-node-to-client---optional#Configuring N2C (Node-to-Client) - Optional":"LedgerSync supports fetching certain data directly from a connected Cardano node using Node-to-Client (N2C) settings.\nThis data, such as protocol parameters, is stored in separate tables typically prefixed with local_.For example, the current protocol parameters fetched via N2C are stored in the local_protocol_param table.","configuration-options#Configuration Options":"You can configure N2C in one of the following ways, depending on whether you're connecting to a local Cardano node or a remote one.","1-connecting-to-a-local-cardano-node#1. Connecting to a Local Cardano Node":"To fetch data from a locally running Cardano node, you need to point to the node's socket path.\nIn the .env file:\nSTORE_CARDANO_N2C_NODE_SOCKET_PATH=/home/Cardano/Setups/node/preview/data/node-ipc/node.socket\nIn application.properties:\nstore.cardano.n2c-node-socket-path=/home/Cardano/Setups/node/preview/data/node-ipc/node.socket","2-connecting-to-a-remote-cardano-node-via-socat#2. Connecting to a Remote Cardano Node via Socat":"If you're connecting to a remote Cardano node and the N2C port has been exposed through socat, you can configure the N2C settings\nusing the host and port of the remote node.\nIn the .env file:\nSTORE_CARDANO_N2C_HOST=<node_host>\nSTORE_CARDANO_N2C_PORT=<socat_port>\nIn application.properties:\nstore.cardano.n2c-host=<node_host>\nstore.cardano.n2c-port=<socat_port>\nNote: Ensure that the relevant settings are only configured in one place (either application.properties or .env) to avoid conflicts. If you're using the .env file, make sure to comment out or remove the corresponding lines in application.properties and vice versa.","environment-variables-reference#Environment Variables Reference":"Here is a reference table for some key environment variables:\nEnvironment Variable  .env or docker compose yml\tProperty Name in application.properties\tDescription\tSPRING_DATASOURCE_URL\tspring.datasource.url\tURL for the PostgreSQL database connection.\tSPRING_DATASOURCE_USERNAME\tspring.datasource.username\tUsername for the PostgreSQL database.\tSPRING_DATASOURCE_PASSWORD\tspring.datasource.password\tPassword for the PostgreSQL database.\tSTORE_CARDANO_HOST\tstore.cardano.host\tCardano relay node host.\tSTORE_CARDANO_PORT\tstore.cardano.port\tCardano relay node port.\tSTORE_CARDANO_PROTOCOLMAGIC\tstore.cardano.protocolMagic\tProtocol magic number for the Cardano network.\tNETWORK\tnetwork\tCardano network to connect to (mainnet, preprod, preview, sanchonet).\tHEALTH_CHECK_ENABLED\thealth.check.enabled\tEnables or disables health checks for the application."}},"/":{"title":"Index","data":{"overview#Overview":"Ledger Sync is a Java application designed to provide efficient access to Cardano blockchain data.Released under an open-source license, Ledger Sync aims to achieve the same data completeness as Cardano DB Sync while\noffering flexibility and customizations for developers. By addressing challenges in blockchain data retrieval and offering\na reliable Java-based solution, Ledger Sync enhances accessibility to blockchain-related data, supporting diverse projects and fostering Cardano's open-source maturity.Ongoing developments include improving functionality, such as parallel processing during initial sync, scoping indexing,\nrewards data, governance off-chain data, granular pattern matching filtering, etc providing blueprints for various development scenarios,\nwith the Foundation encouraging community engagement and contributions to furhter enhance Ledger Sync's capabalities."}},"/schema":{"title":"Schema Documentation for ledger-sync","data":{"pool_hash#pool_hash":"A table for every unique pool key hash.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash_raw\tstring\tThe raw string of the pool hash.\tpool_size\tnumeric\tThe size of the pool.\tepoch_no\tinteger (32)\tThe raw bytes of the pool hash.\tview\tstring\tThe Bech32 encoding of the pool hash.","slot_leader#slot_leader":"Every unique slot leader (ie an entity that mines a block). It could be a pool or a leader defined in genesis.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tstring\tThe hash of of the block producer identifier.\tpool_hash_id\tinteger (64)\tIf the slot leader is a pool, an index into the PoolHash table.\tdescription\tstring\tAn auto-generated description of the slot leader.","block#block":"A table for blocks on the chain.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tstring\tThe hash identifier of the block.\tepoch_no\tinteger (32)\tThe epoch number.\tslot_no\tinteger (64)\tThe slot number.\tepoch_slot_no\tinteger (32)\tThe slot number within an epoch (resets to zero at the start of each epoch).\tblock_no\tinteger (64)\tThe block number.\tprevious_id\tinteger (64)\tThe Block table index of the previous block.\tslot_leader_id\tinteger (64)\tThe SlotLeader table index of the creator of this block.\tsize\tinteger (32)\tThe block size (in bytes). Note, this size value is not expected to be the same as the sum of the tx sizes due to the fact that txs being stored in segwit format and oddities in the CBOR encoding.\ttime\ttimestamp\tThe block time (UTCTime).\ttx_count\tinteger (64)\tThe number of transactions in this block.\tproto_major\tinteger (32)\tThe block's major protocol number.\tproto_minor\tinteger (32)\tThe block's major protocol number.\tvrf_key\tstring\tThe VRF key of the creator of this block.\top_cert\tstring\tThe hash of the operational certificate of the block producer.\top_cert_counter\tinteger (64)\tThe value of the counter used to produce the operational certificate.","schema_version#schema_version":"The version of the database schema. Schema versioning is split into three stages as detailed below. This table should\nonly ever have a single row.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tstage_one\tinteger (64)\tSet up PostgreSQL data types (using SQL 'DOMAIN' statements).\tstage_two\tinteger (64)\tPersistent generated migrations.\tstage_three\tinteger (64)\tSet up database views, indices etc.","tx#tx":"A table for transactions within a block on the chain.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tinteger (64)\tThe hash identifier of the transaction.\tblock_id\tinteger (64)\tThe Block table index of the block that contains this transaction.\tblock_index\tinteger (64)\tThe index of this transaction with the block (zero based).\tout_sum\tnumeric\tThe sum of the transaction outputs .\tfee\tnumeric\tThe fees paid for this transaction.\tdeposit\tinteger (64)\tDeposit (or deposit refund) in this transaction. Deposits are positive, refunds negative.\tsize\tinteger (32)\tThe size of the transaction in bytes.\tinvalid_before\tinteger (64)\tTransaction in invalid before this slot number.\tinvalid_hereafter\tinteger (64)\tTransaction in invalid at or after this slot number.\tvalid_contract\tboolean\tFalse if the contract is invalid. True if the contract is valid or there is no contract.\tscript_size\tinteger (32)\tThe sum of the script sizes (in bytes) of scripts in the transaction.","stake_address#stake_address":"A table of unique stake addresses. Can be an actual address or a script hash. The existance of an entry doesn't mean the\naddress is registered or in fact that is was ever registered.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash_raw\tstring\tThe raw bytes of the stake address hash.\tview\tstring\tThe Bech32 encoded version of the stake address.\tscript_hash\tstring\tThe script hash, in case this address is locked by a script.\tavailable_reward\tnumeric\tThe total amount of ADA rewards that have been accrued by a stake address","tx_out#tx_out":"A table for transaction outputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\taddress\tstring\tThe human readable encoding of the output address. Will be Base58 for Byron era addresses and Bech32 for Shelley era.\taddress_has_script\tboolean\tFlag which shows if this address is locked by a script.\taddress_raw\tbytea\tFlag which shows if this address is locked by a script.\tdata_hash\tstring\tThe hash of the transaction output datum. (NULL for Txs without scripts).\tindex\tsmallint\tThe index of this transaction output with the transaction.\tpayment_cred\tstring\tThe payment credential part of the Shelley address. (NULL for Byron addresses). For a script-locked address, this is the script hash.\ttoken_type\tinteger\tType of token (NATIVE_TOKEN(0),TOKEN(1),ALL_TOKEN_TYPE(2)).\tvalue\tnumeric\tThe output value  of the transaction output.\tinline_datum_id\tinteger (64)\tThe inline datum of the output, if it has one.\treference_script_id\tinteger (64)\tThe reference script of the output, if it has one.\tstake_address_id\tinteger (64)\tThe StakeAddress table index for the stake address part of the Shelley address. (NULL for Byron addresses).\ttx_id\tinteger (64)\tThe Tx table index of the transaction that contains this transaction output.","tx_in#tx_in":"A table for transaction inputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\ttx_in_id\tinteger (64)\tThe Tx table index of the transaction that contains this transaction input.\ttx_out_index\tsmallint\tThe index within the transaction outputs.\ttx_out_id\tinteger (64)\tThe Tx table index of the transaction that contains the referenced transaction output.\tredeemer_id\tinteger (64)\tThe Redeemer table index which is used to validate this input.","reference_tx_in#reference_tx_in":"A table for reference transaction inputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\ttx_in_id\tinteger (64)\tThe Tx table index of the transaction that contains this transaction input\ttx_out_id\tinteger (64)\tThe Tx table index of the transaction that contains the referenced output.\ttx_out_index\tsmallint\tThe index within the transaction outputs.","meta#meta":"A table containing metadata about the chain. There will probably only ever be one row in this table.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tnetwork_name\tstring\tThe network name.\tstart_time\ttimestamp\tThe start time of the network.\tversion\tstring","epoch#epoch":"Aggregation of data within an epoch.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tblk_count\tinteger (32)\tThe number of blocks in this epoch.\tend_time\ttimestamp\tThe epoch end time.\tfees\tnumeric\tThe sum of the fees  in this epoch.\tmax_slot\tinteger\tThe maximum slots of this epoch\tno\tinteger\tThe epoch number.\tout_sum\tnumeric\tThe sum of the transaction output values  in this epoch.\tstart_time\ttimestamp\tThe epoch start time.\ttx_count\tinteger (32)\tThe number of transactions in this epoch.\tera\tinteger\tType of era (BYRON_EBB(0),BYRON(1),SHELLEY(2),ALLEGRA(3),MARY(4),ALONZO(5),BABBAGE(6),CONWAY(7)).\trewards_distributed\tnumeric\tThe total amount of ADA that was distributed as staking rewards during a specific epoch.","ada_pots#ada_pots":"A table with all the different types of total balances (Shelley only).\nThe treasury and rewards fields will be correct for the whole epoch, but all other fields change block by block.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tdeposits\tnumeric\tThe amount  in the obligation pot coming from stake key and pool deposits\tepoch_no\tinteger (32)\tThe epoch number where this AdaPots snapshot was taken.\tfees\tnumeric\tThe amount  in the fee pot.\treserves\tnumeric\tThe amount  in the reserves pot.\trewards\tnumeric\tThe amount  in the rewards pot.\tslot_no\tinteger (64)\tThe slot number where this AdaPots snapshot was taken.\ttreasury\tnumeric\tThe amount  in the treasury pot.\tutxo\tnumeric\tThe amount  in the UTxO set.\tblock_id\tinteger (64)\tThe Block table index of the block for which this snapshot was taken.","pool_metadata_ref#pool_metadata_ref":"An on-chain reference to off-chain pool metadata.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tvarchar\tThe expected hash for the off-chain data.\turl\tvarchar\tThe URL for the location of the off-chain data.\tpool_id\tinteger (64)\tThe PoolHash table index of the pool for this reference.\tregistered_tx_id\tinteger (64)\tThe Tx table index of the transaction in which provided this metadata reference.","pool_update#pool_update":"An on-chain pool update.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tactive_epoch_no\tinteger (64)\tThe epoch number where this update becomes active.\tcert_index\tinteger (32)\tThe index of this pool update within the certificates of this transaction.\tfixed_cost\tnumeric\tThe fixed per epoch fee (in ADA) this pool charges.\tmargin\tdouble\tThe margin (as a percentage) this pool charges.\tpledge\tnumeric\tThe amount the pool owner pledges to the pool.\tvrf_key_hash\tvarchar\tThe hash of the pool's VRF key.\tmeta_id\tinteger (64)\tThe PoolMetadataRef table index this pool update refers to.\thash_id\tinteger (64)\tThe PoolHash table index of the pool this update refers to.\tregistered_tx_id\tinteger (64)\tThe Tx table index of the transaction in which provided this pool update.\treward_addr_id\tinteger (64)\tThe StakeAddress table index of this pool's rewards address.","pool_owner#pool_owner":"A table containing pool owners.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tpool_update_id\tinteger (64)\tThe PoolUpdate table index for the pool.\taddr_id\tinteger (64)\tThe StakeAddress table index for the pool owner's stake address.","pool_retire#pool_retire":"A table containing information about pools retiring.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcert_index\tinteger (32)\tThe index of this pool retirement within the certificates of this transaction.\tretiring_epoch\tinteger (32)\tThe epoch where this pool retires.\tannounced_tx_id\tinteger (64)\tThe Tx table index of the transaction where this pool retirement was announced.\thash_id\tinteger (64)\tThe PoolHash table index of the pool this retirement refers to.","pool_relay#pool_relay":"A table containing information about pools relay.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tdns_name\tstring\tThe DNS name of the relay (NULLable).\tdns_srv_name\tstring\tThe DNS service name of the relay (NULLable).\tipv4\tstring\tThe IPv4 address of the relay (NULLable).\tipv6\tstring\tThe IPv6 address of the relay (NULLable).\tport\tinteger (32)\tThe port number of relay (NULLable).\tupdate_id\tinteger (64)\tThe PoolUpdate table index this PoolRelay entry refers to.","stake_registration#stake_registration":"A table containing stake address registrations.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcert_index\tinteger (32)\tThe index of this stake registration within the certificates of this transaction.\tepoch_no\tinteger (32)\tThe epoch in which the registration took place.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address.\ttx_id\tinteger (64)\tThe Tx table index of the transaction where this stake address was registered.","stake_deregistration#stake_deregistration":"A table containing stake address deregistrations.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcert_index\tinteger (32)\tThe index of this stake deregistration within the certificates of this transaction.\tepoch_no\tinteger (32)\tThe epoch in which the deregistration took place.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address.\tredeemer_id\tinteger (64)\tThe Redeemer table index that is related with this certificate.\ttx_id\tinteger (64)\tThe Tx table index of the transaction where this stake address was deregistered.","delegation#delegation":"A table containing delegations from a stake address to a stake pool.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tactive_epoch_no\tinteger (64)\tThe epoch number where this delegation becomes active.\tcert_index\tinteger (32)\tThe index of this delegation within the certificates of this transaction.\tslot_no\tinteger (64)\tThe slot number of the block that contained this delegation.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address.\tpool_hash_id\tinteger (64)\tThe PoolHash table index for the pool being delegated to.\tredeemer_id\tinteger (64)\tThe Redeemer table index that is related with this certificate.\ttx_id\tinteger (64)\tThe Tx table index of the transaction that contained this delegation.","tx_metadata#tx_metadata":"A table for metadata attached to a transaction.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tbytes\tbytea\tThe raw bytes of the payload.\tjson\ttext\tThe JSON payload if it can be decoded as JSON.\tkey\tnumeric\tThe metadata key.\ttx_id\tinteger (64)\tThe Tx table index of the transaction where this metadata was included.","tx_metadata_hash#tx_metadata_hash":"A table for hash metadata attached to a transaction.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tstring\tThe hash of metadata of transaction.","reward#reward":"A table for earned staking rewards.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tamount\tnumeric\tThe reward amount.\tearned_epoch\tinteger (64)\tThe epoch in which the reward was earned. For pool and leader rewards spendable in epoch N, this will be N - 2, refund N.\tspendable_epoch\tinteger (64)\tThe epoch in which the reward is actually distributed and can be spent.\ttype\tstring\tThe type of the rewards (\"leader\", \"member\",\"reserves\",\"treasury\",\"refund\")\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address that earned the reward.\tpool_id\tinteger (64)\tThe PoolHash table index for the pool the stake address was delegated to when the reward is earned or for the pool that there is a deposit refund.","withdrawal#withdrawal":"A table for withdrawals from a reward account.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tamount\tnumeric\tThe withdrawal amount.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address for which the withdrawal is for.\tredeemer_id\tinteger (64)\tThe Redeemer table index that is related with this withdrawal.\ttx_id\tinteger (64)\tThe Tx table index for the transaction that contains this withdrawal.","epoch_stake#epoch_stake":"A table containing the epoch stake distribution for each epoch.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tamount\tnumeric\tThe amount being staked.\tepoch_no\tinteger (32)\tThe epoch number.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address for this EpochStake entry.\tpool_id\tinteger (64)\tThe PoolHash table index for the pool this entry is delegated to.","treasury#treasury":"A table for payments from the treasury to a StakeAddress.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tamount\tnumeric\tThe payment amount.\tcert_index\tinteger (32)\tThe index of this payment certificate within the certificates of this transaction.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address for this Treasury entry.\ttx_id\tinteger (64)\tThe Tx table index for the transaction that contains this payment.","reserve#reserve":"A table for payments from the reserves to a StakeAddress.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tamount\tnumeric\tThe payment amount.\tcert_index\tinteger (32)\tThe index of this payment certificate within the certificates of this transaction.\taddr_id\tinteger (64)\tThe StakeAddress table index for the stake address for this Treasury entry.\ttx_id\tinteger (64)\tThe Tx table index for the transaction that contains this payment.","pot_transfer#pot_transfer":"A table containing transfers between the reserves pot and the treasury pot.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcert_index\tinteger (32)\tThe index of this transfer certificate within the certificates of this transaction.\treserves\tnumeric\tThe amount the reserves balance changes by.\ttreasury\tnumeric\tThe amount the treasury balance changes by.\ttx_id\tinteger (64)\tThe Tx table index for the transaction that contains this transfer.","epoch_sync_time#epoch_sync_time":"A table containing the time required to fully sync an epoch.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tno\tinteger (64)\tThe epoch number for this sync time.\tseconds\tinteger (64)\tThe time (in seconds) required to sync this epoch (may be NULL for an epoch that was already partially synced when db-sync was started).\tstate\tstring\tThe sync state when the sync time is recorded (either 'lagging' or 'following').","multi_asset#multi_asset":"A table containing all information the unique policy/name pairs along with a CIP14 asset fingerprint\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tfingerprint\tstring\tThe CIP14 fingerprint for the MultiAsset.\tname\tbytea\tThe MultiAsset name.\tpolicy\tstring\tThe MultiAsset policy hash.\tunit\tstring\tThe MultiAsset unit.\tsupply\tnumeric\tThe MultiAsset supply.\ttime\ttimestamp\tThe MultiAsset time.\tname_view\tstring\tThe MultiAsset name view.","ma_tx_mint#ma_tx_mint":"A table containing Multi-Asset mint events.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tquantity\tnumeric\tThe amount of the Multi Asset to mint (can be negative to \"burn\" assets).\tident\tinteger (64)\tThe MultiAsset table index specifying the asset.\ttx_id\tinteger (64)\tThe Tx table index for the transaction that contains this minting event.","ma_tx_out#ma_tx_out":"A table containing Multi-Asset transaction outputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tquantity\tnumeric\tThe Multi Asset transaction output amount (denominated in the Multi Asset).\tident\tinteger (64)\tThe MultiAsset table index specifying the asset.\ttx_out_id\tinteger (64)\tThe TxOut table index for the transaction that this Multi Asset transaction output.","redeemer#redeemer":"A table containing redeemers. A redeemer is provided for all items that are validated by a script.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tfee\tnumeric\tThe budget in fees to run a script. The fees depend on the ExUnits and the current prices. Is null when --disable-ledger is enabled.\tindex\tword31type\tThe index of the redeemer pointer in the transaction.\tpurpose\tstring\tWhat kind pf validation this redeemer is used for. It can be one of 'spend', 'mint', 'cert', 'reward'.\tscript_hash\tstring\tThe script hash this redeemer is used for.\tunit_mem\tinteger (64)\tThe budget in Memory to run a script.\tunit_steps\tinteger (64)\tThe budget in Cpu steps to run a script.\tredeemer_data_id\tinteger (64)\tThe data related to this redeemer.\ttx_id\tinteger (64)\tThe Tx table index that contains this redeemer.","script#script":"A table containing scripts available, found in witnesses, inlined in outputs (reference outputs) or auxdata of\ntransactions.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tbytes\tbytea\tCBOR encoded plutus script data, null for other script types\thash\tstring\tThe Hash of the Script.\tjson\ttext\tJSON representation of the timelock script, null for other script types\tserialised_size\tinteger (32)\tThe size of the CBOR serialised script, if it is a Plutus script.\ttype\tstring\tThe type of the script. This is currenttly either 'timelock' or 'plutus'.\ttx_id\tinteger (64)\tThe Tx table index for the transaction where this script first became available.\tverified\tbool\tCheck the script has been verified.","datum#datum":"A table containing Plutus Datum, found in witnesses or inlined in outputs\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tbytes\tbytea\tThe actual data in CBOR format\thash\tstring\tThe Hash of the Datum\tvalue\ttext\tThe actual data in JSON format (detailed schema)\ttx_id\tinteger (64)\tThe Tx table index for the transaction where this script first became available.","redeemer_data#redeemer_data":"A table containing Plutus Redeemer Data. These are always referenced by at least one redeemer. New in v13: split from\ndatum table.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tbytes\tbytea\tThe actual data in CBOR format\thash\tstring\tThe Hash of the Plutus Data\tvalue\ttext\tThe actual data in JSON format (detailed schema)\ttx_id\tinteger (64)\tThe Tx table index for the transaction where this script first became available.","extra_key_witness#extra_key_witness":"A table containing transaction extra key witness hashes.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash\tstring\tThe hash of the witness.\ttx_id\tinteger (64)\tThe id of the tx this witness belongs to.","param_proposal#param_proposal":"A table containing block chain parameter change proposals.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcoins_per_utxo_size\tnumeric\tFor Alonzo this is the cost per UTxO word. For Babbage and later per UTxO byte.\tcollateral_percent\tinteger (32)\tThe percentage of the txfee which must be provided as collateral when including non-native scripts.\tdecentralisation\tdouble\tThe decentralisation parameter (1 fully centralised, 0 fully decentralised).\tentropy\tstring\tThe 32 byte string of extra random-ness to be added into the protocol's entropy pool.\tepoch_no\tinteger (64)\tThe epoch for which this parameter proposal in intended to become active. Always null in Conway era.\tinfluence\tdouble\tThe influence of the pledge on a stake pool's probability on minting a block.\tkey\tstring\tThe hash of the crypto key used to sign this proposal. Always null in Conway era.\tkey_deposit\tnumeric\tThe amount (in Lovelace) require for a deposit to register a StakeAddress.\tmax_bh_size\tnumeric\tThe maximum block header size (in bytes).\tmax_block_ex_mem\tnumeric\tThe maximum number of execution memory allowed to be used in a single block.\tmax_block_ex_steps\tnumeric\tThe maximum number of execution steps allowed to be used in a single block.\tmax_block_size\tnumeric\tThe maximum block size (in bytes).\tmax_collateral_inputs\tinteger (32)\tThe maximum number of collateral inputs allowed in a transaction.\tmax_epoch\tnumeric\tThe maximum number of epochs in the future that a pool retirement is allowed to be scheduled for.\tmax_tx_ex_mem\tnumeric\tThe maximum number of execution memory allowed to be used in a single transaction.\tmax_tx_ex_steps\tnumeric\tThe maximum number of execution steps allowed to be used in a single transaction.\tmax_tx_size\tnumeric\tThe maximum transaction size (in bytes).\tmax_val_size\tnumeric\tThe maximum Val size.\tmin_fee_a\tnumeric\tThe 'a' parameter to calculate the minimum transaction fee.\tmin_fee_b\tnumeric\tThe 'b' parameter to calculate the minimum transaction fee.\tmin_pool_cost\tnumeric\tThe minimum pool cost.\tmin_utxo_value\tnumeric\tThe minimum value of a UTxO entry.\tmonetary_expand_rate\tdouble\tThe monetary expansion rate.\toptimal_pool_count\tnumeric\tThe optimal number of stake pools.\tpool_deposit\tnumeric\tThe amount (in Lovelace) require for a deposit to register a stake pool.\tprice_mem\tdouble\tThe per word cost of script memory usage.\tprice_step\tdouble\tThe cost of script execution step usage.\tprotocol_major\tinteger (32)\tThe protocol major number.\tprotocol_minor\tinteger (32)\tThe protocol minor number.\ttreasury_growth_rate\tdouble\tThe treasury growth rate.\tcost_model_id\tinteger (64)\tThe CostModel table index for the proposal.\tregistered_tx_id\tinteger (64)\tThe Tx table index for the transaction that contains this parameter proposal.\tpvt_motion_no_confidence\tdouble\tPool Voting threshold for motion of no-confidence.\tpvt_committee_normal\tdouble\tPool Voting threshold for new committee/threshold (normal state).\tpvt_committee_no_confidence\tdouble\tPool Voting threshold for new committee/threshold (state of no-confidence).\tpvt_hard_fork_initiation\tdouble\tPool Voting threshold for hard-fork initiation.\tpvt_p_p_security_group\tdouble\tPool Vote threshold for protocol parameter changes, security group.\tpvt_p_p_technical_group\tdouble\tPool Vote threshold for protocol parameter changes, technical group.\tpvt_p_p_gov_group\tdouble\tPool Vote threshold for protocol parameter changes, governance group.\tpvt_treasury_withdrawal\tdouble\tPool Vote threshold for treasury withdrawal.\tdvt_motion_no_confidence\tdouble\tDRep Vote threshold for motion of no-confidence.\tdvt_committee_normal\tdouble\tDRep Vote threshold for new committee/threshold (normal state).\tdvt_committee_no_confidence\tdouble\tDRep Vote threshold for new committee/threshold (state of no-confidence).\tdvt_update_to_constitution\tdouble\tDRep Vote threshold for update to the Constitution.\tdvt_hard_fork_initiation\tdouble\tDRep Vote threshold for hard-fork initiation.\tdvt_p_p_network_group\tdouble\tDRep Vote threshold for protocol parameter changes, network group.\tdvt_p_p_economic_group\tdouble\tDRep Vote threshold for protocol parameter changes, economic group.\tcommittee_min_size\tnumeric\tMinimal constitutional committee size.\tcommittee_max_term_length\tnumeric\tConstitutional committee term limits.\tgov_action_lifetime\tnumeric\tGovernance action expiration.\tgov_action_deposit\tnumeric\tGovernance action deposit.\tdrep_deposit\tnumeric\tDRep deposit amount.\tdrep_activity\tnumeric\tDRep activity period.\tmin_fee_ref_script_cost_per_byte\tnumeric\tMin fee ref script cost per byte","epoch_param#epoch_param":"The accepted protocol parameters for an epoch.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcoins_per_utxo_size\tnumeric\tFor Alonzo this is the cost per UTxO word. For Babbage and later per UTxO byte.\tcollateral_percent\tinteger (32)\tThe percentage of the txfee which must be provided as collateral when including non-native scripts.\tdecentralisation\tdouble\tThe decentralisation parameter (1 fully centralised, 0 fully decentralised).\tepoch_no\tinteger (32)\tThe first epoch for which these parameters are valid.\textra_entropy\tstring\tThe 32 byte string of extra random-ness to be added into the protocol's entropy pool.\tinfluence\tdouble\tThe influence of the pledge on a stake pool's probability on minting a block.\tkey_deposit\tnumeric\tThe amount require for a deposit to register a StakeAddress.\tmax_bh_size\tinteger (32)\tThe maximum block header size (in bytes).\tmax_block_ex_mem\tnumeric\tThe maximum number of execution memory allowed to be used in a single block.\tmax_block_ex_steps\tnumeric\tThe maximum number of execution steps allowed to be used in a single block.\tmax_block_size\tinteger (32)\tThe maximum block size (in bytes).\tmax_collateral_inputs\tinteger (32)\tThe maximum number of collateral inputs allowed in a transaction.\tmax_epoch\tinteger (32)\tThe maximum number of epochs in the future that a pool retirement is allowed to be scheduled for.\tmax_tx_ex_mem\tnumeric\tThe maximum number of execution memory allowed to be used in a single transaction.\tmax_tx_ex_steps\tnumeric\tThe maximum number of execution steps allowed to be used in a single transaction.\tmax_tx_size\tinteger (32)\tThe maximum transaction size (in bytes).\tmax_val_size\tnumeric\tThe maximum Val size.\tmin_fee_a\tinteger (32)\tThe 'a' parameter to calculate the minimum transaction fee.\tmin_fee_b\tinteger (32)\tThe 'b' parameter to calculate the minimum transaction fee.\tmin_pool_cost\tnumeric\tThe minimum pool cost.\tmin_utxo_value\tnumeric\tThe minimum value of a UTxO entry.\tmonetary_expand_rate\tdouble\tThe monetary expansion rate.\tnonce\tstring\tThe nonce value for this epoch.\toptimal_pool_count\tinteger (32)\tThe optimal number of stake pools.\tpool_deposit\tnumeric\tThe amount (in Lovelace) require for a deposit to register a stake pool.\tprice_mem\tdouble\tThe per word cost of script memory usage.\tprice_step\tdouble\tThe cost of script execution step usage.\tprotocol_major\tinteger (32)\tThe protocol major number.\tprotocol_minor\tinteger (32)\tThe protocol minor number.\ttreasury_growth_rate\tdouble\tThe treasury growth rate.\tblock_id\tinteger (64)\tThe Block table index for the first block where these parameters are valid.\tcost_model_id\tinteger (64)\tThe CostModel table index for the params.\tpvt_motion_no_confidence\tdouble\tPool Voting threshold for motion of no-confidence.\tpvt_committee_normal\tdouble\tPool Voting threshold for new committee/threshold (normal state).\tpvt_committee_no_confidence\tdouble\tPool Voting threshold for new committee/threshold (state of no-confidence).\tpvt_hard_fork_initiation\tdouble\tPool Voting threshold for hard-fork initiation.\tpvt_p_p_security_group\tdouble\tPool Vote threshold for protocol parameter changes, security group.\tpvt_p_p_technical_group\tdouble\tPool Vote threshold for protocol parameter changes, technical group.\tpvt_p_p_gov_group\tdouble\tPool Vote threshold for protocol parameter changes, governance group.\tpvt_treasury_withdrawal\tdouble\tPool Vote threshold for treasury withdrawal.\tdvt_motion_no_confidence\tdouble\tDRep Vote threshold for motion of no-confidence.\tdvt_committee_normal\tdouble\tDRep Vote threshold for new committee/threshold (normal state).\tdvt_committee_no_confidence\tdouble\tDRep Vote threshold for new committee/threshold (state of no-confidence).\tdvt_update_to_constitution\tdouble\tDRep Vote threshold for update to the Constitution.\tdvt_hard_fork_initiation\tdouble\tDRep Vote threshold for hard-fork initiation.\tdvt_p_p_network_group\tdouble\tDRep Vote threshold for protocol parameter changes, network group.\tdvt_p_p_economic_group\tdouble\tDRep Vote threshold for protocol parameter changes, economic group.\tcommittee_min_size\tnumeric\tMinimal constitutional committee size.\tcommittee_max_term_length\tnumeric\tConstitutional committee term limits.\tgov_action_lifetime\tnumeric\tGovernance action expiration.\tgov_action_deposit\tnumeric\tGovernance action deposit.\tdrep_deposit\tnumeric\tDRep deposit amount.\tdrep_activity\tnumeric\tDRep activity period.\tmin_fee_ref_script_cost_per_byte\tnumeric\tMin fee ref script cost per byte","cost_model#cost_model":"CostModel for EpochParam and ParamProposal.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tcosts\ttext\tThe actual costs formatted as json.\thash\tstring\tThe hash of cost model. It ensures uniqueness of entries.","reserved_pool_ticker#reserved_pool_ticker":"A table containing a managed list of reserved ticker names.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tname\tstring\tThe ticker name.\tpool_hash\tstring\tThe hash of the pool that owns this ticker.","delisted_pool#delisted_pool":"A table containing pools that have been delisted.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\thash_raw\tstring\tThe pool hash","unconsume_tx_in#unconsume_tx_in":"A table for unconsume transaction inputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\ttx_in_id\tinteger (64)\tThe Tx table index of the transaction that contains this transaction input.\ttx_out_index\tsmallint\tThe index within the transaction outputs.\ttx_out_id\tinteger (64)\tThe Tx table index of the transaction that contains the referenced transaction output.\tredeemer_id\tinteger (64)\tThe Redeemer table index which is used to validate this input.","tx_witnesses#tx_witnesses":"A table for transaction witnesses.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\ttx_id\tinteger (64)\tThe Tx table index of the transaction.\tkey\tstring\tKey used for signing the transaction.\tsignature\tstring\tThe signature of the transaction.\tindex_arr\tinteger[]\tArray containing the transaction index.\tindex_arr_size\tinteger (32)\tSize of index array.\ttype\tstring\tType of transaction witnesses.","tx_bootstrap_witnesses#tx_bootstrap_witnesses":"A table for transaction bootstrap witnesses.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\ttx_id\tinteger (64)\tThe Tx table index of the transaction.\tpublic_key\tstring\tPublic key of the transaction.\tsignature\tstring\tThe signature of the transaction.\tchain_code\tstring\tThe chain code of the transaction.\tattributes\tstring\tThe attributes of the transaction.","rollback_history#rollback_history":"A table for rollback history.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tblock_hash\tstring\tThe hash of block.\tblock_no\tinteger (64)\tThe number of hash.\trollback_time\ttimestamp\tRollback time.\tslot_no\tinteger (64)\tThe slot number.","pool_offline_data#pool_offline_data":"The pool offchain (ie not on chain) for a stake pool.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tbytes\tbytea\tThe raw bytes of the payload.\thash\tstring\tThe hash identifier of the pool.\tjson\tstring\tThe payload as JSON.                                 .\tticker_name\tstring\tThe pool's ticker name.\tpool_id\tinteger (64)\tThe pool index.\tpmr_id\tinteger (64)\tThe PoolMetadataRef table index for this offchain data.\tpool_name\tstring\tName of pool.\tlogo_url\tstring\tLogo url of pool.\ticon_url\tstring\tIcon url of pool.","pool_offline_fetch_error#pool_offline_fetch_error":"A table containing pool offchain data fetch errors.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\tfetch_error\tstring\tThe text of the error.\tfetch_time\ttimestamp\tThe UTC time stamp of the error.\tretry_count\tinteger (32)\tThe number of retries.\tpool_id\tinteger (64)\tThe PoolHash table index for the pool this offchain fetch error refers.\tpmr_id\tinteger (64)\tThe PoolMetadataRef table index for this offchain data.","failed_tx_out#failed_tx_out":"A table for transaction collateral outputs.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (64)\t\taddress\tstring\tThe human readable encoding of the output address. Will be Base58 for Byron era addresses and Bech32 for Shelley era.\taddress_has_script\tboolean\tFlag which shows if this address is locked by a script.\taddress_raw\tbytea\tFlag which shows if this address is locked by a script.\tdata_hash\tstring\tThe hash of the transaction output datum. (NULL for Txs without scripts).\tindex\tsmallint\tThe index of this transaction output with the transaction.\tmulti_assets_descr\ttext\tThis is a description of the multiassets in collateral output. Since the output is not really created, we don't need to add them in separate tables.\tpayment_cred\tstring\tThe payment credential part of the Shelley address. (NULL for Byron addresses). For a script-locked address, this is the script hash.\tvalue\tnumeric\tThe output value (in Lovelace) of the transaction output.\tinline_datum_id\tinteger (64)\tThe inline datum of the output, if it has one.\treference_script_id\tinteger (64)\tThe reference script of the output, if it has one.\tstake_address_id\tinteger (64)\tThe StakeAddress table index for the stake address part of the Shelley address. (NULL for Byron addresses).\ttx_id\tinteger (64)\tThe Tx table index of the transaction that contains this transaction output.","committee_deregistration#committee_deregistration":"A table for every committee key de-registration.\nPrimary Id: {tx_hash, cert_index}\nColumn name\tType\tDescription\ttx_hash\tstring\tHash of the tx that includes this certificate.\tcert_index\tinteger (32)\tThe index of this deregistration within the certificates of this transaction.\tanchor_url\tstring\tURL that links to documents or additional information about deregistering a committee key\tanchor_hash\tstring\tHash of anchor_url\tcold_key\tstring\tThe deregistered cold key.\tcred_type\tstring\tCredential type used in deregistration (ADDR_KEYHASH, SCRIPTHASH).\tepoch\tinteger (32)\tThe epoch number at the time of deregistration.\tslot\tinteger (64)\tThe slot number at the time of deregistration.\tblock\tinteger (64)\tBlock number in the blockchain at the time of deregistration.\tblock_time\tinteger (64)\tTime of the block containing the deregistration transaction.\tupdate_datetime\ttimestamp\tThe update time of record","committee_registration#committee_registration":"A table for every committee key registration.\nPrimary Id: {tx_hash, cert_index}\nColumn name\tType\tDescription\ttx_hash\tstring\tHash of the tx that includes this certificate.\tcert_index\tinteger (32)\tThe index of this registration within the certificates of this transaction.\tcold_key\tstring\tThe deregistered cold key.\thot_key\tstring\tThe deregistered hot key.\tcred_type\tstring\tCredential type used in registration (ADDR_KEYHASH, SCRIPTHASH).\tepoch\tinteger (32)\tThe epoch number at the time of registration.\tslot\tinteger (64)\tThe slot number at the time of registration.\tblock\tinteger (64)\tBlock number in the blockchain at the time of registration.\tblock_time\tinteger (64)\tTime of the block containing the registration transaction.\tupdate_datetime\ttimestamp\tThe update time of record","committee_member#committee_member":"A table for members of the committee. A committee can have multiple members.\nPrimary Id: {hash, slot}\nColumn name\tType\tDescription\thash\tstring\tThe committee hash.\tcred_type\tstring\tType of credential (ADDR_KEYHASH, SCRIPTHASH).\tstart_epoch\tinteger (32)\tThe epoch this member start.\texpired_epoch\tinteger (32)\tThe epoch this member expires.\tslot\tinteger (64)\tSlot number.\tupdate_datetime\ttimestamp\tThe update time of record","constitution#constitution":"A table for constitutiona attached to a GovActionProposal.\nPrimary Id: active_epoch\nColumn name\tType\tDescription\tactive_epoch\tinteger (64)\tThe epoch this constitutiona attached.\tanchor_url\tstring\tURL of the document or information source containing the details of the constitution.\tanchor_hash\tstring (64)\tHash of anchor_url.\tscript\tstring\tThe Script Hash.\tslot\tinteger (64)\tSlot number.\tupdate_datetime\ttimestamp\tThe update time of record.","cursor_#cursor_":"Table to track the current block position during synchronization.\nPrimary Id: id\nColumn name\tType\tDescription\tid\tinteger (32)\t\tblock_hash\tstring\tThe hash of block.\tslot\tinteger (64)\tSlot number.\tblock_number\tinteger (64)\tBlock number\tera\tinteger (32)\tType of era (BYRON_EBB(0),BYRON(1),SHELLEY(2),ALLEGRA(3),MARY(4),ALONZO(5),BABBAGE(6),CONWAY(7)).\tprev_block_hash\tstring\tThe hash of previous block.\tcreate_datetime\ttimestamp\tThe create time of record.\tupdate_datetime\ttimestamp\tThe update time of record.","delegation_vote#delegation_vote":"A table containing delegations from a stake address to a stake pool.\nPrimary Id: {tx_hash, cert_index}\nColumn name\tType\tDescription\ttx_hash\tstring\tHash of the tx that includes this certificate.\tcert_index\tinteger (32)\tThe index of this transfer certificate within the certificates of this transaction.\taddress\tstring\tThe stake address.\tdrep_hash\tstring\tThe Drep hash for the pool being delegated to.\tdrep_id\tstring\tDrep index for the pool being delegated to.\tdrep_type\tstring\tThe Drep type (ADDR_KEYHASH, SCRIPTHASH, ABSTAIN,NO_CONFIDENCE).\tepoch\tinteger (32)\tThe epoch number at the time of delegation vote.\tcredential\tstring\tThe Certification information related to votes.\tcred_type\tstring\tThe credential type (ADDR_KEYHASH, SCRIPTHASH).\tslot\tinteger (64)\tSlot number.\tblock\tinteger (64)\tBlock number.\tblock_time\tinteger (64)\tTime when the block containing the transaction was created..\tupdate_datetime\ttimestamp\tThe update time of record","drep_registration#drep_registration":"A table for DRep registrations, deregistrations or updates.\nPrimary Id: {tx_hash, cert_index}\nColumn name\tType\tDescription\ttx_hash\tstring\tHash of the tx\tcert_index\tinteger (32)\tThe index of this registration within the certificates of this transaction.\ttype\tvarchar(50)\tType of DREP registration (e.g., stake pool registration, withdrawal)\tdeposit\tinteger (64)\tAmount of ADA deposited for specific registration types\tdrep_hash\tvarchar(56)\tDrep hash for the pool being delegated to\tdrep_id\tvarchar(255)\tUnique identifier for  a delegated representative (Bech32)\tanchor_url\tvarchar\tURL for additional information about the registration\tanchor_hash\tvarchar(64)\tHash of the off-chain data pointed to by anchor_url\tcred_type\tvarchar(40)\tType of credential used for registration (ADDR_KEYHASH, SCRIPTHASH)\tepoch\tinteger (32)\tEpoch number\tslot\tinteger (64)\tSlot number\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tBlock time\tupdate_datetime\ttimestamp\tDate and time the record was last updated","era#era":"A table for era information\nByron(1), Shelley(2), Allegra(3), Mary(4), Alonzo(5), Babbage(6), Conway(7);\nPrimary Id: era\nColumn name\tType\tDescription\tera\tinteger (32)\tEra identifier\tstart_slot\tinteger (64)\tSlot number at which the era begins\tblock\tinteger (64)\tBlock number that marks the start of the era\tblock_hash\tstring\tHash of the block that starts the era","flyway_schema_history#flyway_schema_history":"A table for the execution history of Flyway schema migrations.\nColumn name\tType\tDescription\tinstalled_rank\tinteger (32)\tIndex the order of the records in the table, determining the order in which changes were applied.\tversion\tstring\tThe version of the change applied\tdescription\tstring\tBrief description of the applied change\ttype\tstring\tType of change\tscript\tstring\tThe name of the script file containing the applied changes\tchecksum\tinteger (32)\tChecksum value of the script file, helps detect changes in the script file\tinstalled_by\tstring\tThe name of the user or process to which the change was applied\tinstalled_on\ttimestamp\tTime when the change was applied\texecution_time\tinteger (32)\tFile execution time\tsuccess\tbool\tStatus of change","gov_action_proposal#gov_action_proposal":"A table contains information about proposed government actions.\nPrimary Id: {tx_hash, idx}\nColumn name\tType\tDescription\ttx_hash\tstring\tThe hash of the tx that includes this certificate\tidx\tinteger (32)\tThe index of this proposal procedure within its transaction\tdeposit\tinteger (64)\tThe deposit amount payed for this proposal (in lovelace)\treturn_address\tstring\tThe reward address that receive the deposit when it is repaid\tanchor_url\tstring\tURL for additional information about the proposal\tanchor_hash\tstring\tHash of the off-chain data pointed to by anchor_url\ttype\tstring\tCan be one of ParameterChange, HardForkInitiation, TreasuryWithdrawals, NoConfidence, NewCommittee, NewConstitution, InfoAction\tdetails\tjsonb\tJSON document describing the content of  governance action\tepoch\tinteger (32)\tEpoch number\tslot\tinteger (64)\tSlot number\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tBlock time\tupdate_datetime\ttimestamp\tDate and time the record was last updated","voting_procedure#voting_procedure":"A table for voting procedures, aka GovVote. A Vote can be Yes No or Abstain.\nPrimary Id: {tx_hash, voter_hash, gov_action_tx_hash, gov_action_index}\nColumn name\tType\tDescription\ttx_hash\tstring\tTransaction hash of the tx that includes this VotingProcedure\tvoter_hash\tstring\tHash identifying the voter (not null, part of primary key)\tgov_action_tx_hash\tstring\tTransaction hash of the governance action\tgov_action_index\tinteger (32)\tThe index of this proposal procedure within its transaction\tid\tuuid\tUnique identifier\tidx\tinteger (32)\tThe index of this VotingProcedure within this transaction\tvoter_type\tstring\tThe role of the voter. Can be one of ConstitutionalCommittee, DRep, SPO\tvote\tstring\tThe Vote. Can be one of Yes, No, Abstain\tanchor_url\tstring\tURL for additional information about the vote\tanchor_hash\tstring\tHash of the off-chain data pointed to by anchor_url\tepoch\tinteger (32)\tEpoch number\tslot\tinteger (64)\tSlot number\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tBlock time\tupdate_datetime\ttimestamp\tDate and time the record was last updated","committee#committee":"A table for new committee information\nPrimary Id: epoch\nColumn name\tType\tDescription\tgov_action_tx_hash\tstring (64)\tTransaction hash of the corresponding governance action proposal\tgov_action_index\tinteger(32)\tThe index of the corresponding governance action proposal within its transaction\tthreshold_numerator\tinteger (64)\tThreshold numerator\tthreshold_denominator\tinteger (64)\tThreshold denominator\tthreshold\tdouble\tThreshold value\tepoch\tinteger (32)\tEpoch number\tslot\tinteger (64)\tSlot number\tupdate_datetime\ttimestamp\tDate and time the record was last updated","address_balance#address_balance":"A table for balance of address\nPrimary Id: {address, unit, slot}\nColumn Name\tData Type\tDescription\taddress\tstring\tBech32 encoded address\tunit\tstring\tThe unit for the quantity (e.g., lovelace for ADA)\tslot\tinteger (64)\tSlot number\tquantity\tnumeric\tNumeric representation of the asset amount\taddr_full\ttext\tFull address details in Cardano format\tpolicy\tstring\tPolicy ID (fingerprint) of the off-chain asset definition\tasset_name\tstring\tOptional human-readable name of the asset\tblock_hash\tstring\tHash of the block\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tBlock time\tepoch\tinteger (32)\tEpoch number\tupdate_datetime\ttimestamp\tDate and time the record was last updated","stake_address_balance#stake_address_balance":"A table for balance of stake address\nPrimary Id: {address, slot}\nColumn Name\tData Type\tDescription\taddress\tstring\tBech32 encoded stake address\tslot\tinteger (64)\tSlot number\tquantity\tnumeric\tNumeric representation of the lovelace\tstake_credential\tstring\tStake credential associated with the address\tblock_hash\tstring\tHash of the block\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tUnix timestamp representing the time the block was produced\tepoch\tinteger (32)\tEpoch number\tupdate_datetime\ttimestamp\tDate and time the record was last updated","address_tx_amount#address_tx_amount":"A table for the change in the balance of an address at a specific transaction.\nPrimary Id: {address, unit, tx_hash}\nColumn Name\tData Type\tDescription\taddress\tstring\tBech32 encoded address\tunit\tstring\tOptional unit for the quantity (e.g., lovelace for ADA)\ttx_hash\tstring\tThe hash identifier of the transaction\tslot\tinteger (64)\tSlot number\tquantity\tnumeric\tNumeric representation of the asset amount involved in the transaction\taddr_full\ttext\tFull address details in Cardano format\tstake_address\tstring\tBech32 encoded stake address associated with the transaction\tblock\tinteger (64)\tBlock number\tblock_time\tinteger (64)\tUnix timestamp representing the time the block was produced\tepoch\tinteger (32)\tEpoch number when the transaction occurred","account_config#account_config":"A table containing information about account config\nPrimary Id: config_id\nColumn Name\tData Type\tDescription\tconfig_id\tstring\tUnique identifier for the account configuration\tstatus\tstring\tCurrent status of the account configuration (BALANCE_SNAPSHOT)\tslot\tinteger (64)\tSlot number\tblock\tinteger (64)\tBlock number\tblock_hash\tstring\tHash of the block","address_utxo#address_utxo":"A table for transaction outputs (Used for account balance calculator).\nPrimary Id: {tx_hash, output_index,}\nColumn name\tType\tDescription\ttx_hash\tstring\tThe hash identifier of the transaction that contains this transaction output\toutput_index\tsmallint\tThe index of this transaction output with the transaction\tslot\tinteger (64)\tSlot number\tblock_hash\tstring\tHash of the block\tepoch\tinteger (32)\tEpoch number\tlovelace_amount\tinteger (64)\tThe output value (in Lovelace) of the transaction output\tamounts\tjsonb\tObject containing the amount of each multi-asset coin in the UTXO.","tx_input#tx_input":"A table for tx inputs which reference outputs from previous transactions (Used for account balance calculator).\nPrimary Id: {tx_hash, output_index,}\nColumn name\tType\tDescription\ttx_hash\tstring\tThe hash identifier of the transaction\toutput_index\tsmallint\tThe index within the transaction outputs\tspent_at_slot\tinteger (64)\tSlot number in which the UTXO was spent\tspent_at_block\tinteger (64)\tBlock number in which the UTXO was spent\tspent_at_block_hash\tstring\tUnique identifier for the block containing the spending transaction\tspent_block_time\tinteger (64)\tUnix timestamp of the block containing the spending transaction\tspent_epoch\tinteger (32)\tEpoch number when the UTXO was spent\tspent_tx_hash\tstring\tUnique identifier for the spending transaction","address#address":"A table for information about address\nPrimary Id: id\nColumn name\tType\tDescription\tid\tbigserial\tUnique identifier for the address (auto-incrementing)\taddress\tstring\tBech32 address in the Cardano blockchain.\taddr_full\ttext\tFull address information (might include more details)\tpayment_credential\tstring\tBech32 payment credential for the address\tstake_address\tstring\tBech32 stake address associated with the address\tstake_credential\tstring\tBech32 stake credential associated with the address\tupdate_datetime\ttimestamp\tTimestamp of the last update to this record."}},"/use-cases":{"title":"Use Cases","data":{"":"Lets start with some common uses cases, we will add more here in future:"}},"/use-cases/WalletQueries":{"title":"Wallet","data":{"":"By the end of this tutorial, you should be able to run the following queries leveraging Ledger Sync to gather the necessary data for building your own Cardano Wallet.You can verify results using any of the community explorers listed here."}},"/use-cases/WalletQueries/wallet01":{"title":"Wallet01","data":{"1-find-the-ada-balance-of-a-wallet#1. Find the ADA balance of a wallet":"Let's start with something simple but essential: viewing your portfolio. Specifically, we'll look at how to display the total balance of ADA holdings associated with a wallet address.\nBefore we dive in, ensure that you have installed and configured Ledger Sync on your chosen network. Allow it to fully synchronize, and once the database is synced, you can start performing SQL queries using your preferred tool.\nThe following networks are available:\nPrivate Testnet\nSanchonet Testnet ...see also Sancho.network\nPreview Testnet\nPre-production Testnet\nProduction (Mainnet)\nFor most of our examples, we will query the same preprod address, which takes the following format:\nYou can get test tokens for pre-production and preview testnets using this faucet\nFor SanchoNet tokens, go to the SanchoNet faucet.\nSELECT\n    (coalesce(sum1.value,0) - coalesce(sum2.value,0)) as result\nFROM\n    (SELECT\n        SUM(to1.value) as value\n    FROM tx_out to1\n    WHERE\n        to1.address = ''\n    ) as sum1,\n    \n    (SELECT\n        SUM(to2.value) as value\n    FROM tx_in ti\n    JOIN tx_out to2 ON\n        ti.tx_out_id = to2.tx_id\n        AND ti.tx_out_index = to2.\"index\"\n    WHERE\n        to2.address = ''\n    ) as sum2;\nExpected results format\n4645032877132\nThere are few ways to obtain this information. In this SQL query, we calculate the balance of a specific address by subtracting the the total funds spent from the total funds received. In UTXO terms, we are subtracting the total value of spent outputs from the total value of received outputs.\nNote: Cardano (like Bitcoin) leverages the Unspent Transaction Output (UTXO) model to keep track of user state/balances. This is different to the account-based model employed by Ethereum. Cardano implements an innovative Extended Unspent Transaction Output (EUTxO) model. If you are new to Cardano, or need a recap, the EUTxO crash course from the Aiken team is essential reading.\n🔎 Here's a breakdown of what the query does:","calculate-the-balance-between-the-following-two-sub-queries#Calculate the Balance between the following two sub-queries:":"SELECT (COALESCE(sum1.value, 0) - COALESCE(sum2.value, 0)) as result \nFROM (subquery1) AS sum1, (subquery2) AS sum2\nThe main clause calculates the difference between the total received value sum1.value and the total spent value sum2.value. The COALESCE function is used to ensure that if either sum1.value or sum2.value is NULL, it is treated as '0'. The result is aliased as result. The FROM clause contains two nested subqueries, which are outlined next.","calculate-total-received-value#Calculate Total Received Value:":"SELECT SUM(to1.value) as value\nFROM tx_out to1\nWHERE to1.address = ''\nThis first subquery sum1 calculates the total value of all outputs sent (in lovelace) to the specified address .\nThe FROM tx_out to1 clause specifies the tx_out table as the source and gives it the alias to1 for easier reference. The WHERE to1.address clause filters the results to only include transactions for our address.","calculate-total-spent-value#Calculate Total Spent Value:":"SELECT SUM(to2.value) as value\nFROM tx_in ti\nJOIN tx_out to2 ON\n    ti.tx_out_id = to2.tx_id\n    AND ti.tx_out_index = to2.\"index\"\nWHERE to2.address = ''\nThis second subquery sum2 calculates the total value of all outputs (in lovelace) from the specified address that have been spent. It does this by joining the tx_in (alias ti) and tx_out (alias to2) tables to find the corresponding spent outputs.\nThe JOIN condition ensures we only count outputs that were used as inputs in other transactions (i.e., spent funds). WHERE to2.address filters the results to only include transactions for our address and the result is also aliased as value.","summary#Summary:":"This query effectively provides the current balance of the specified address by querying the database for:\nThe total lovelace this has address received (sum1)\nThe total lovelace this address sent (sum2)\nThe difference between the two (result)\nAnother way to check the balance is by summing up all the UTXOs associated with the wallet address."}},"/use-cases/WalletQueries/wallet02":{"title":"Wallet02","data":{"2-list-a-balances-utxos#2. List a balance's UTXOs":"The goal of this query is to identify all Unspent Transaction Outputs (UTXOs) associated with one specific Cardano address. In simpler terms, it's like checking the individual coins and tokens in the wallet that haven't been spent yet.\nSELECT\n\ttx.hash AS tx_hash,\n\ttxo.\"index\" AS tx_out_index,\n\ttxo.value AS value,\n\td.hash AS datum_hash,\n\ts.hash AS script_hash\nFROM tx_out txo\nLEFT JOIN tx_in ti \n\tON ti.tx_out_index = txo.\"index\" AND ti.tx_out_id = txo.tx_id \nJOIN tx\n\tON tx.id = txo.tx_id\nLEFT JOIN datum d ON d.id = txo.inline_datum_id  \nLEFT JOIN script s ON s.id = txo.reference_script_id  \nWHERE\n    txo.address = ''\n    AND ti.id IS NULL\nExpected results format\n     tx_hash                                                     | tx_out_index |    value       | datum_hash | script_hash\n-----------------------------------------------------------------+--------------+----------------+------------+------------ \n |     0        |  3228190       |            |           \n |     1        |  4605029648942 |            |            \n |     0        |  40000000000\t |            |                 \n(3 rows)\nIt's important to understand how UTxOs are referenced on Cardano. As shown below, a UTxO consists of the reference to the transaction that created it (TxId), and its index (TxIx) on the host transaction. A UTxO is associated with an asset value, an address which dictates its spending conditions and other metadata. A transaction can take multiple inputs (consuming multiple UTxOs) and produce multiple outputs (new UTxOs to be used by future transactions).\n🔎 Let's breakdown how this query works.","selecting-the-information-ie-retrieving-the-utxos#'SELECT'ing the information, ie. retrieving the UTXOS:":"Specifically, we are looking for:\ntx.hash The unique id (hash) of the transaction.\ntxo.\"index\" The index (position) of the UTXO within the transaction.\ntxo.value selects the value associated with the transaction output, ie. the amount of ADA and any tokens held in that output.\nd.hash The hash of any associated datum (think of this as optional additional data attached to the UTXO).\ns.hash (Optional) The hash of any associated script (an optional script detailing the conditions for spending the UTXO).","table-joins#Table JOINs":"tx_out txo table with information about transaction outputs.\ntx_in ti table with information about transaction inputs. We join these tables so we can check if a UTXO has been spent, i.e., used as an input.\nThis tx table holds general transaction information.\ndatum d & script s tables hold optional extra data about the UTXO. We use LEFT JOIN because not all UTXOs will have datum or scripts attached.","filters#Filters":"Filters results for our specific address\ntxo.address = \nti.id IS NULL is an important condition as it ensures we only get unspent UTXOs, i.e. UTXOs that haven't been used as inputs yet.","summary#Summary":"The query starts by looking at all transaction outputs from the tx_out table.\nIt verifies each output belongs to our specific address.\nIt looks for matches in the tx_in table to see if the output has been used as an input.\nIf no match is found, ti.id IS NULL, then it's an unspent UTXO.\nFinally, it fetches any additional information about the optional datum and script, if they exist, and presents the results.\nNow that you know your balance, you might want to see where it came from. To do this, we'll create a query to fetch the transaction history associated with this address and display it in a list, including additional details for each transaction."}},"/use-cases/WalletQueries/wallet03":{"title":"Wallet03","data":{"3-review-wallet-transaction-history#3. Review wallet transaction history":"For consistency, we will query the same preprod address as before:\n🔎 You can verify results using any of the community explorers listed here.CardanoScan search (remember to choose 'Preprod' in the top right)We will break the query up into three parts to fetch the information we need for the overall query.","31-transaction-details#3.1 Transaction details":"First, let's determine which transaction details we want to collect:\namount of ADA transferred\nif the transaction is incoming/outgoing\ntransaction fee\nassets (name and quantity)\ntransaction hash\nTimestamp\nSlot/Block\n-- Transactions where the address is the output\nSELECT\n\tCOALESCE(sum(tx_out.value), 0) - COALESCE(inp.inp_value, 0) AS ADA_amount,\n\t'outgoing' AS direction,\n\ttx.fee AS fee,\n\ttx.hash AS tx_hash,\n\tblock.\"time\" AS time_stamp,\n\tblock.block_no AS block,\n\tblock.slot_no AS slot\nFROM tx_out\nJOIN tx ON tx.id = tx_out.tx_id\nLEFT JOIN ( SELECT\n\t\ttx.id AS inp_txid,\n\t\ttx.hash AS inp_hash,\n\t\ttx_out.address AS source_add,\n\t\tsum(tx_out.value) AS inp_value\n           FROM tx_in\n\t   JOIN tx_out ON tx_out.tx_id = tx_in.tx_out_id\n\t\t    AND tx_out.index = tx_in.tx_out_index\n    \t   JOIN tx ON tx.id = tx_in.tx_in_id\n\t   WHERE\n\t\ttx_out.address = ''\n           GROUP BY\n\t\tinp_txid,\n\t\tinp_hash,\n\t\tsource_add\n    \t\t) \n    \tAS inp ON inp.inp_txid = tx.id\nJOIN block ON block.id = tx.block_id\nWHERE\n\ttx_out.address = ''\nGROUP BY\n\ttx_hash,\n\tdirection,\n\tfee,\n\ttime_stamp,\n\tblock,\n\tslot,\n\tinp.inp_value\nUNION\n-- Transactions where the address is the input and not an output\nSELECT\n    sum(tx_out.value) AS ADA_amount,\n\t'incoming' AS direction,\n\ttx.fee AS fee,\n\ttx.hash AS tx_hash,\n\tblock.\"time\" AS time_stamp,\n\tblock.block_no AS block,\n\tblock.slot_no AS slot\nFROM tx_in\nJOIN tx_out ON tx_out.tx_id = tx_in.tx_out_id\n\t\t\tAND tx_out.index = tx_in.tx_out_index\nJOIN tx ON tx.id = tx_in.tx_in_id\nJOIN block ON block.id = tx.block_id\nWHERE\n\ttx_out.address = ''\n\tAND NOT EXISTS (SELECT 1 AS txid\n\t\t\t\t\tFROM tx_out\n\t\t\t\t\tWHERE\n\t\t\t\t\t\ttx_out.address = ''\n\t\t\t\t\t\tAND tx_out.tx_id = tx.id )\nGROUP BY\n\ttx_hash,\n\tdirection,\n\tfee,\n\ttime_stamp,\n\tblock,\n\tslot\nExpected results format\n     ada_amount\t  | direction |  fee    |                         tx_hash                                  |      time_stamp       |   block   |  slot\n------------------+-----------+---------+------------------------------------------------------------------+-----------------------+-----------+------------\n2,000,000,000,000 | outgoing  | 174,961 |  | 2024-02-05 20:13:48.00| 1,899,032 |  51,480,828\n    -199,601      | outgoing  | 199,601\t|  | 2023-07-10 02:37:30.00| 1,143,600 |  33,273,450\n39,735,569,942\t  | outgoing  | 177,469 |  | 2023-12-12 04:39:20.00| 1,692,918 |  46,672,760\n             \n(Note: results trimmed for readability)\nThe overall aim is to track the flow of ADA for our specific address. It categorizes transactions as 'outgoing' or 'incoming' and provides details like the amount, fee, timestamp, and block information.\nWhen we say \"outgoing\", this is the address that is in the output of that transaction, and possibly the input as well (if they are receiving any change back).\nWhen we say \"incoming\", this is the address in the input part of that transaction, and not in the output part.\n🔎 Let's take a closer look at each part of the query.","first-part-before-union#First Part (Before UNION)":"SELECT COALESCE(sum(tx_out.value), 0) - COALESCE(inp.inp_value, 0) AS ADA_amount, 'outgoing' AS direction, ...This SELECT statement calculates the net ADA amount involved in transactions where the given address is an output, ie. recipient.\nCOALESCE ensures that if sum(tx_out.value) or inp.inp_value is NULL, they are treated as 0, preventing errors.\noutgoing labels these transactions as outgoing.FROM tx_out JOIN tx ON tx.id = tx_out.tx_id ...\nThis FROM statement starts by looking at tx_out (transaction outputs) and joins it with the tx\n(transactions) table, linking them based on transaction IDs.LEFT JOIN ( SELECT ... ) AS inp ON inp.inp_txid = tx.id is a subquery aliased as inp. It looks for transactions where the given address is an input (or sender) and calculates the total input value inp_value for those transactions.LEFT JOIN includes all rows from the left table tx even if there's no match in the subquery inp.JOIN block ON block.id = tx.block_id joins the block table to get block-related information (timestamp, block number, slot number).WHERE tx_out.address = '...' filters results to only include transactions where the specified address is an output.GROUP BY tx_hash, ... groups the results by transaction hash and other fields to avoid duplicate rows.UNION combines the results of the first part with the second part.","second-part-after-union#Second Part (After UNION)":"SELECT sum(tx_out.value) AS ADA_amount, 'incoming' AS direction, ... calculates the total ADA amount for incoming transactions.incoming labels these transactions as incoming. FROM tx_in JOIN tx_out ON ... JOIN tx ON ... JOIN block ON ... similar joins as in the first part, but starts from tx_in (transaction inputs).WHERE tx_out.address = '...' AND NOT EXISTS (SELECT 1 AS txid FROM tx_out WHERE ...) filters to include transactions where:\nThe address is an input (via tx_out linked to tx_in).\nThe address is not an output in the same transaction (using NOT EXISTS).\nGROUP BY tx_hash, ... groups the results similarly to the first part.","32-retrieve-transaction-signatories#3.2 Retrieve Transaction signatories":"Next we will run a query to get the transaction signatories. :writing_hand:For that, we will be using the transaction hash  as it has more than one signer keys.\nSELECT tw.\"key\" AS Transaction_Signatories\n\t\t\tFROM tx\n\t\t\tLEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id\n\t\t\tWHERE tx.hash = ''\nExpected results format\n     transaction_signatories\n----------------------------------------------------------------\n(2 rows)\n🔎  Let's take a closer look at each part of the query.SELECT tw.\"key\" AS Transaction_Signatories selects the key column from the tx_witnesses table and renames it as Transaction_Signatories in the output.FROM tx means the query is looking in the tx table.LEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id performs a LEFT JOIN with the tx_witnesses table.\nLEFT JOIN tx_witnesses tw ON tx.id = tw.tx_id performs a LEFT JOIN with the tx_witnesses table.The JOIN condition tx.id = tw.tx_id connects rows from both tables where the id in the tx table matches the tx_id in the tx_witnesses table.LEFT JOIN ensures that all rows from the tx table are included in the result, even if there's no corresponding match in the tx_witnesses table. In such cases, the columns from tx_witnesses will have NULL values.WHERE tx.hash = '' is a filtering condition restricting the output to only those rows where the hash column in the tx table matches the provided specific hash value.","33-retrieve-native-asset-details#3.3 Retrieve Native Asset details":"While reviewing the above transactions, you might notice that some include more than just ADA, they also include Cardano Native Assets.Next we will run a query get the details of a specific transaction which includes a native asset. We will use the transaction hash  because this transaction has native assets, in addtion to ada.\nSELECT tx_detail.* FROM (\t\n\t\t\tSELECT \n\t\t\t\t'output' AS direction,\n\t\t\t\ttx_out.address AS address,\n\t\t\t\tsa.\"view\" AS stake_address,\n\t\t\t\ttx_out.value AS ADA_amount,\n\t\t\t\tma.name AS asset_name,\n\t\t\t\tsum(mto.quantity) AS quantity,\n\t\t\t\tb.time AS time_stamp,\n\t\t\t\ttx.fee AS transaction_fee,\n\t\t\t\tb.block_no AS block,\n\t\t\t\tb.slot_no AS slot,\n\t\t\t\tNULL AS utxo\n\t\t\tFROM tx\n\t\t\t\tLEFT JOIN tx_out ON tx_out.tx_id = tx.id\n\t\t\t\tLEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id\n\t\t\t\tLEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id\n\t\t\t\tLEFT JOIN multi_asset ma ON ma.id = mto.ident\n\t\t\t\tLEFT JOIN block b ON b.id = tx.block_id\n\t\t\tWHERE\n\t\t\t\ttx.hash = ''\n\t\t\tGROUP BY direction, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, utxo\n\t\t\t\t\n\t\t\tUNION ALL\n\t\t\tSELECT \n\t\t\t\t'input' AS direction,\n\t\t\t\ttx_out.address AS address,\n\t\t\t\tsa.\"view\" AS stake_address,\n\t\t\t\ttx_out.value ADA_amount,\n\t\t\t\tma.name AS asset_name,\n\t\t\t\tsum(mto.quantity) AS quantity,\n\t\t\t\tb.time AS time_stamp,\n\t\t\t\ttx.fee AS transaction_fee,\n\t\t\t\tb.block_no AS block,\n\t\t\t\tb.slot_no AS slot,\n\t\t\t\ttxin.hash AS utxo\n\t\t\tFROM tx\n\t\t\t\tLEFT JOIN tx_in ti ON ti.tx_in_id = tx.id\n\t\t\t\tLEFT JOIN tx_out ON tx_out.tx_id = ti.tx_out_id AND tx_out.\"index\" = ti.tx_out_index \n\t\t\t\tLEFT JOIN tx txin ON txin.id = tx_out.tx_id\n\t\t\t\tLEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id\n\t\t\t\tLEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id\n\t\t\t\tLEFT JOIN multi_asset ma ON ma.id = mto.ident\n\t\t\t\tLEFT JOIN block b ON b.id = tx.block_id\n\t\t\tWHERE\n\t\t\t\ttx.hash = ''\n\t\t\tGROUP BY direction, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, utxo\n\t\t\t\t) AS tx_detail\nORDER BY tx_detail.direction ASC\nExpected results format\ndirection  | address \t\t\t          |  stake_addres                    | ada_amount    | asset_name | quantity |  time_stamp  | transaction_fee| block  | slot    |  utxo\t\n-----------+------------------------------+----------------------------------+---------------+------------+----------+--------------+----------------+--------+---------+---------------\ninput      | addr_test1qr...09cae0svmt57t | stake_test1urfvl...8juwuhclq5pxz | 4531923278317 | tDRIP      | 1000020  |  2024-04-03  | 196917         | 2106415| 56425275| a55dca...ff747\n \n(Note: results trimmed for readability)\n🔎  Let's zoom in for a closer look at each part of the query.","two-subqueries-combined-with-union-all#Two Subqueries Combined with UNION ALL":"The main query selects everything prefixed tx_detail by combining the results of two subqueries using UNION ALL which appends the results of the second subquery to the first, without removing duplicates.","first-subquery-focuses-on-outputs#First Subquery focuses on Outputs":"SELECT 'output' AS direction, ... labels each row as an 'output'.\nFROM tx LEFT JOIN tx_out ... starts from the tx table and joins with tx_out (transaction outputs) table to get output details.\nLEFT JOIN stake_address ... joins with stake_address to get associated stake address information.\nLEFT JOIN ma_tx_out ... LEFT JOIN multi_asset ... joins to gather details about any native assets involved in the outputs.\nLEFT JOIN block b ... joins with block to get block-related info.\nWHERE tx.hash = '...' filters to focus only on the specific transaction.\nGROUP BY ... groups results to avoid redundancy, especially when multiple native assets are involved in an output.\nNULL AS utxo sets the utxo column to NULL for outputs, as UTXOs are relevant to inputs.","second-subquery-focuses-on-inputs#Second Subquery focuses on Inputs":"SELECT 'input' AS direction, ... labels each row as an 'input'.\nFROM tx LEFT JOIN tx_in ... starts from tx table and joins with tx_in (transaction inputs) table.\nLEFT JOIN tx_out ... LEFT JOIN tx txin ... traces back from the input to the original output it's spending, to get details about that output.\nOther joins and WHERE clause are similar to the first subquery.\ntxin.hash AS utxo includes the hash of the transaction that created the spent output, representing the UTXO.","main-query#Main Query":"SELECT tx_detail.* FROM (...) AS tx_detail selects all columns from the combined results of the subqueries.\nORDER BY tx_detail.direction ASC orders the results, showing outputs first, then inputs.","summary#Summary":"This query gives you a detailed breakdown of the inputs and outputs of the Cardano transaction we are interested in.Next, we will run a query to fetch a breakdown list of all the native tokens (both fungible tokens and NFTs) held in the wallet. This will provide a detailed view of your various assets, allowing you to see each token or NFT along with its name and quantity."}},"/use-cases/WalletQueries/wallet04":{"title":"Wallet04","data":{"4-list-all-tokens-in-a-wallet#4. List all tokens in a wallet":"Some assets, particularly NFTs, may include additional information detailed in their metadata. For instance, in-game NFTs can have attributes such as power, speed, and strength encoded in this metadata. This information follows the standards set by various Cardano Improvement Proposals, such as CIP-25, which define how metadata should be structured for assets on the Cardano blockchain.\nMetadata standards for Cardano are covered in CIPs (Cardano Improvement Proposals) 25, 26, 60 and 68\nTo keep things simple, we will use the same address as before:🔎 You can also verify the details on one of many Cardano Community Explorers listed here. For this one, lets use Cardanoscan 🎯To retrieve the metadata, you can use the following query:\nSELECT\n     ma.fingerprint,\n    ma.name AS name,\n    sum(mto.quantity) AS quantity\nFROM\n    ma_tx_out mto\nJOIN multi_asset ma \n\tON ma.id = mto.ident \nJOIN tx_out \n\tON mto.tx_out_id = tx_out.id\nLEFT JOIN tx_in ti \n\tON ti.tx_out_index = tx_out.\"index\" AND ti.tx_out_id = tx_out.tx_id \nWHERE\n    tx_out.address = ''\n    AND ti.tx_out_id is null\nGROUP BY ma.fingerprint, ma.name\nExpected results format\n     fingerprint                              |       name      |    quantity\n----------------------------------------------+-----------------+--------------- \nasset1anpme6pcrc4jax2h230gm4pgmwsz80u27qsufq  | tBigTokenName03 |     20           \nasset1etk8c8pscc0f6hy6q4wc3nphk9znj0xagv9acz  | tBigTokenName01 |     20                \nasset1gvxdk7yhzupnruv9h54jc9eenf30w55xuq43vf  | tBigTokenName05 |     20         \nasset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm  |     tDRIP       |  1,000,020\nasset1qftk8hza6hn50lm2pl88wl8gea5fan5zhgx8gm  | tBigTokenName10 |     10\nasset1rpsx8nx8gzmwt62tuzdwq66qj8jrdmsgjv6qsa  | tBigTokenName08 |     20\nasset1t87nuhlan33l68hhtgmt3zfks3lwupayncz0k3  | tBigTokenName07 |     20\nasset1tfpfjaz57vpcddwzxdz49f8pc7zmlswjfjfwwx  | tBigTokenName04 |     20\nasset1uvkv85rk6pklfcdm39ht0yq60pf2fawtwndu2w  | tBigTokenName06 |     20\nasset1vyddw8jc6w9679smf4d4d8r4qn7g2pzkqhgktd  | tBigTokenName02 |     20\nasset1zutmprtn8te56av95m09sxj305rxm7yps3e3vr  | tBigTokenName09 |     20            \n(11 rows)\nAt a high level, we are listing all the distinct tokens (fungible tokens) and NFTs (non-fungible tokens) present in our specific Cardano wallet address, along with their respective quantities. This is essential for wallet applications to display a user's asset holdings accurately. We are checking unspent Multi-Asset transaction output from the ma_tx_out table for our specific address. 🔎 Let's break it down line by line:","select-the-right-information#SELECT the right information:":"ma.fingerprint ,ie. the unique fingerprint of the token/NFT.\nma.name ...this is the name of the token/NFT (often used to distinguish NFTs).\nsum(mto.quantity), ie. the total quantity of that specific token/NFT held in the wallet, calculated by summing quantities across UTXOs.","table-joins#Table JOINs":"ma_tx_out mto table stores information about multi-asset quantities within transaction outputs.\nmulti_asset ma table stores the metadata for each multi-asset.\nThe tx_out table stores general transaction output information.\ntx_in ti table stores transaction input information. We use this to check if a UTXO is spent.","filters#Filters":"tx_out.address = ''...we are filtering for our specific wallet address.\nti.tx_out_id IS NULL is an important condition ensuring we only consider unspent transaction outputs (UTXOs) since those are the ones containing the assets currently held in the wallet.","grouping-and-aggregating#Grouping and Aggregating":"GROUP BY ma.fingerprint, ma.name clause groups the results by the unique fingerprint and name of each token/NFT, enabling us to calculate the total quantity held.\nSUM(mto.quantity) calculates the total quantity of each token/NFT by summing up the quantities found in all relevant UTXOs.","summary#Summary":"The query looks at all transaction outputs containing multi-assets.\nIt checks if the outputs belong to the specified wallet address and are unspent.\nIt retrieves the fingerprint and name of the multi-asset from the multi_asset table.\nIt groups the results by fingerprint and name, summing up the quantities to get the total amount of each token/NFT held at our wallet address.\nIt returns a list of all the distinct tokens and NFTs in the wallet, along with their respective quantities."}},"/use-cases/WalletQueries/wallet06":{"title":"Wallet06","data":{"6-query-token-metadata#6. Query Token metadata":"In this SQL query, we retrieve the JSON metadata associated with a specific asset by joining multiple tables and applying filters.\nSELECT tm.json\nFROM ma_tx_mint mtm\nJOIN tx_metadata tm ON tm.tx_id = mtm.tx_id\nJOIN multi_asset ma ON ma.id = mtm.ident\nWHERE\n    ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'\n    AND tm.key = 721\nORDER BY\n    mtm.id DESC\nLIMIT 1\nExpected results format\n{\n   \"\":{\n      \"tDRIP\":{\n         \"image\":\"ipfs://QmfUKSqkaJ8WNuvPzuYsTVZ8aDht3GGKKuzxrhi6S2orNw\",\n         \"name\":\"tDRIP\",\n         \"mediaType\":\"image/png\",\n         \"attributes\":{\n            \"publisher\":[\n               \"zeronin ❤️ Memecoin (@Contactdrip) on X \",\n               \"https://dripdropz.io\"\n            ]\n         }\n      }\n   }\n🔎 Here's a breakdown of how this query works:","select-json-metadata#Select JSON Metadata:":"SELECT tm.json\nThis part of the query specifies that we want to retrieve the json column from the tx_metadata table.","from-ma_tx_mint-table-with-joins#From ma_tx_mint Table with Joins":"FROM ma_tx_mint mtm\nJOIN tx_metadata tm ON tm.tx_id = mtm.tx_id\nJOIN multi_asset ma ON ma.id = mtm.ident\nThe data is being retrieved from the ma_tx_mint table, aliased as mtm.The query joins the tx_metadata table tm, using the tx_id (transaction id) column. The multi_asset table, alised ma, is joined with the indent column. using ma.id = mtm.ident.","filter-by-fingerprint-and-metadata-key#Filter by Fingerprint and Metadata Key":"WHERE\n    ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'\n    AND tm.key = 721\nThis condition filters the rows to include only those where the ma.fingerprint matches our specific native asset id asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm. tm.key = 721 is referring to 721 which is the metatdata standard for NFTs on Cardano.","order-and-limit-the-results#Order and Limit the Results":"ORDER BY\n    mtm.id DESC\nLIMIT 1\nThe results are ordered by mtm.id in descending order, which means the most recent entry comes first. The LIMIT 1 clause ensures that only the most recent entry is returned.","summary#Summary":"The query retrieves the JSON metadata for a specific asset by:\nJoining the ma_tx_mint, tx_metadata, and multi_asset tables from Ledger Sync's database schema.\nFiltering by the asset's fingerprint and extract the JSON metadata associated with the minting transaction, specifically the metadata related to the NFT standard (721). This metadata contains details about the NFT's name, image, policy ID, etc.\nOrdering by the most recent minting transaction and limiting the result to one.\nNow that you understood about metadata and have a list of all the assets, you may want to gather more details about a specific collection. This could include information such as the policy ID of the collection, the creation date, the number of assets minted, the number of owners, number of transactions in the last 24 hours, and any unique attributes associated with it."}},"/use-cases/WalletQueries/wallet05":{"title":"Wallet05","data":{"5-query-collection-details#5. Query collection details":"To keep things simple, we will use the same address as before:🔎 You can also verify the details on one of many Cardano Community Explorers listed here. For this one, lets use Cardanoscan 🎯For this example, we are querying this specific token asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm. We want to retrieve the following details: a) Script hash, b) Total supply, c)creation date, d) Number of holders, e) Number of transactions in the past week.\nSELECT\n\t\tma.policy AS scriptHash,\n\t\tma.supply AS totalSupply,\n\t\tma.time AS createdDate,\n\t\tnum_of_holders.numHolder,\n\t\tnum_of_tx.numTx\n\tFROM\n\t\tpreprod.multi_asset ma\n\tLEFT JOIN (\n\t\t\tSELECT ma.fingerprint AS fingerprint, COUNT(DISTINCT tx.id) AS numTx\n\t\t\tFROM tx\n\t\t\tLEFT JOIN tx_out txo ON tx.id = txo.tx_id \n\t\t\tJOIN block b ON b.id = tx.block_id \n\t\t\tJOIN ma_tx_out mto ON txo.id = mto.tx_out_id\n\t\t\tJOIN multi_asset ma ON mto.ident = ma.id\n\t\t\tWHERE\n\t\t\t   ma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'\n\t\t\t   AND b.time > (now() at time zone 'utc') - INTERVAL '7 days'\n\t\t\tGROUP BY ma.fingerprint\n\t\t\t) AS num_of_tx ON num_of_tx.fingerprint = ma.fingerprint\n\tLEFT JOIN (\n\t\t\tSELECT ma.fingerprint AS fingerprint, COUNT(DISTINCT(sa.id)) AS numHolder\n\t\t\tFROM ma_tx_out mto\n\t\t\tLEFT JOIN tx_out to2 ON mto.tx_out_id = to2.id\n\t\t\tLEFT JOIN tx_in ti ON ti.tx_out_index = to2.\"index\"\n\t\t\t\tAND ti.tx_out_id = to2.tx_id\n\t\t\tJOIN multi_asset ma ON ma.id = mto.ident\n\t\t\tLEFT JOIN stake_address sa ON sa.id = to2.stake_address_id\n\t\t\tWHERE\n\t\t\t\tma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'\n\t\t\t\tAND ti.id IS NULL\n\t\t\t\tAND sa.id IS NOT NULL\n\t\t\tGROUP BY ma.fingerprint\n\t\t\t) AS num_of_holders ON num_of_holders.fingerprint = ma.fingerprint\n\tWHERE\n\t\tma.fingerprint = 'asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm'\nExpected results format\n     scripthash                                          |      totalsupply       |        createddate |datum_hash | numtx\n---------------------------------------------------------+------------------------+--------------------+-----------+------- \n | 45,000,000,000,000,000 | 2022-12-12 18:28:01|  1,046    |  33           \n    \n(1 rows)\n🔎 We can always cross check our results on any Cardano Explorer, such as cexplorer 🎯🧐 Let's breakdown the query line by line:","data-sources#Data Sources":"The query traverses multiple tables to find the requested details:\nmulti_asset (alias ma) table stores information about the asset itself.\ntx, ie. transaction data.\ntx_outstores transaction output data, where assets end up after a transaction.\nblock refers to blockchain block data. Transactions are grouped into blocks.\nma_tx_out table links multi-asset entries to transaction outputs.\nstake_address table stores information about wallet addresses.","main-query-selectfrom#Main Query (SELECT...FROM)":"The query starts by selecting the desired columns from the multi_asset table.\nIt filters for the target asset using it's unique fingerprint asset1nvcwnq60jnm27efjm87xnhqt6alsv024tdyxjm","first-subquery-left-joinnum_of_tx#First Subquery (LEFT JOIN...num_of_tx)":"This subquery calculates the number of transactions within the past 7 days for our specific asset.\nIt joins transaction data with block data to filter by time.\nIt groups the results by the asset's fingerprint and counts distinct transaction IDs.","second-subquery-left-joinnum_of_holders#Second Subquery (LEFT JOIN...num_of_holders)":"This subquery calculates the number of distinct holders of the asset.\nIt queries transaction outputs tx_out and the links to multi-assets.\nIt filters out transaction outputs that are inputs to other transactions.\nIt counts distinct stake addresses associated with the remaining outputs, where each address represents a holder.","joining-subqueries#Joining Subqueries":"The main query uses a LEFT JOIN to combine the results of the two subqueries back to the main multi_asset table.\nThe LEFT JOIN ensures that the main query returns a row even if the subqueries don't find matching data (in that case, num_of_tx and num_of_holders would be NULL).","summary#Summary":"A fingerprint is a unique identifier used to distinguish different assets on the Cardano blockchain.\nThe LEFT JOIN type of join ensures you get results even if there's no matching data in the joined tables.\nSubqueries are used to calculate more complex values like transaction counts and holder counts that can't be directly derived from a single table."}},"/use-cases/WalletQueries/wallet07":{"title":"Wallet07","data":{"7-query-active-stake-pools#7. Query Active Stake Pools":"Staking is a big part of the Cardano ecosystem. To get started, the first step is to identify the active stake pools. Our next SQL query retrieves information about active Cardano staking pools, retrievign the pool's ID, name and creation date.\nCardanoscan shows active stake pools by default. There is a toggle button to 'Show Inactive Pools' 🔎\nselect ph.id ,\n\t\tCOALESCE(po.pool_name, ph.\"view\") as pool_name,\n\t\tpo.ticker_name as pool_ticker,\n\t\tb.\"time\" AS creation_date,\n\t\tROW_NUMBER() OVER (ORDER BY ph.id ASC) \n\tFROM\n\t\tpool_hash ph\n\tLEFT JOIN pool_offline_data po on\n\t\tph.id = po.pool_id\n\t\tand (po.id is null\n\t\t\tor po.id = (SELECT max(po2.id)\n\t\t\t\t\t\tFROM pool_offline_data po2\n\t\t\t\t\t\tWHERE po2.pool_id = ph.id))\n\tLEFT JOIN pool_update pu on\n\t\tph.id = pu.hash_id\n\t\tand pu.id = (SELECT\tmin(pu2.id)\n\t\t\t\t\t\tFROM pool_update pu2\n\t\t\t\t\t\tWHERE pu2.hash_id = ph.id)\n\tLEFT JOIN tx ON tx.id = pu.registered_tx_id \n\tLEFT JOIN block b ON tx.block_id = b.id \n\tWHERE ph.id NOT IN (SELECT pr.hash_id\n\t\t\t\t        FROM pool_retire pr\n\t\t\t\t        LEFT JOIN pool_update pu on\tpr.hash_id = pu.hash_id\n\t\t\t\t        LEFT JOIN pool_hash ph ON ph.id = pr.hash_id\n\t\t\t\t        GROUP BY pr.hash_id, pu.cert_index, pr.cert_index\n\t\t\t\t        HAVING (max(pu.registered_tx_id) < max(pr.announced_tx_id))\n\t\t\t\t        \tOR ((max(pu.registered_tx_id) = max(pr.announced_tx_id)) AND (max(pu.cert_index) < max(pr.cert_index)))\n\t\t\t\t\t\t) \nExpected results format\n     id   |      pool_name\t      \t  |  pool_ticker |      creation_date \n----------+---------------------------+--------------+-------------------------- \n     4    |      ANGEL stake pool     |     ANGEL    |  2022-10-20 21:21:59.000\n\t 5    |      CanadaStakes\t      |     CAN1     |  2022-10-20 21:30:58.000\n\t 6\t  |     SION stake pool\t      |     SION     |  2022-10-20 21:35:52.000\n\t 7\t  |  PANL Stake Pool(Pre-Prod)|\t    PANL\t |  2022-10-20 22:24:32.000\n     .    |      ................     |     .....    |  .................\n           \n(Note: full results trimmed for readability)\n🔎 Here's a breakdown of how the query works:","select-specific-columns#Select Specific Columns":"In order to gather information about staking pools, the query focuses on:\nPool ID ph.id, the unique identifier for each staking pool\nPool Name pool_name, the human-readable name of the pool\nTicker pool_ticker, an abbreviation of the pool\ncreation_date, the date the pool was created","tables-involved#Tables Involved":"The query traverses several tables (aliases are in brackets):\npool_hash (ph) stores the unique hash identifiers for each pool.\npool_offline_data (po) contains additional information about the pool, such as its name and ticker.\npool_update (pu) tracks updates or changes made to stake pools. It's joined to find the initial registration transaction of a pool pu.registered_tx_id.\ntx stores transaction data.\nblock (b) stores information about blocks, including their timestamps b.time, which are used to determine the pool's creation date.\npool_retire (pr) holds information about stake pools that have been retired or de-registered.","joins-and-subqueries#Joins and Subqueries":"LEFT JOIN pool_offline_data po on ...\nJoins pool_hash with pool_offline_data to get the pool name and ticker.\nThe complex ON condition ensures that for each pool hash:\na) the most recent pool_offline_data entry if any exists, b)\nb) If no pool_offline_data exists for the pool, we still include the pool in the results (due to the LEFT JOIN).\nLEFT JOIN pool_update pu on ... joins pool_hash with pool_update to get the earliest registration transaction for each pool using a subquery to find the minimum pu.id for each pu.hash_id.LEFT JOIN tx ON tx.id = pu.registered_tx_id joins the pool_update with the tx table to get the transaction associated with the pool's registration.LEFT JOIN block b ON tx.block_id = b.id joins the tx table with the block table to get the block in which the registration transaction was included, allowing us to retrieve the creation date.WHERE ph.id NOT IN (SELECT ...) is important for filtering out retired stake pools. The subquery identifies retired pools by comparing the registration and retirement transactions and their certificate indices within those transactions. It ensures that only active pools are included in the final result","select-clause-details#SELECT Clause Details:":"COALESCE(po.pool_name, ph.\"view\") as pool_name uses COALESCE to prioritize the pool_name from pool_offline_data. If it's null, it falls back to the view from pool_hash. This ensures we have a name for each pool.b.\"time\" AS creation_date retrieves the time from the block table (associated with the pool's registration transaction) and labels it as creation_date.ROW_NUMBER() OVER (ORDER BY ph.id ASC) assigns a sequential row number to each result row, ordered by the pool hash ID in ascending order. This can be useful for pagination or displaying results in a numbered list.\nThe next query will provide users with detailed information about specific stake pools. This will help them make informed decisions when selecting a specific pool to delegate their ADA."}},"/use-cases/WalletQueries/wallet08":{"title":"Wallet08","data":{"8-query-stake-pool-details#8. Query Stake Pool details":"This query retrieves detailed information about a specific staking pool, including its name, ticker, identifier, hash, fixed cost, margin, declared pledge, total lifetime blocks produced, and associated stake account address. For this qury, we will use pool ID \nSELECT \n\tph.id ,\n\tpo.pool_name as pool_name,\n\tpo.ticker_name as pool_ticker,\n\tph.view as pool_id,\n\tph.hash_raw AS pool_hash,\n\tpu.fixed_cost AS fixed_cost,\n\tpu.margin AS margin,\n\tpu.pledge AS declared_pledge,\n\tltb.lifetime_blocks as lifetime_blocks,\n\tsa.view AS stake_account\nFROM\n\tpool_hash ph\nLEFT JOIN pool_offline_data po on\n\tph.id = po.pool_id\n\tand (po.id is null\n\t\tor po.id = (SELECT max(po2.id)\n\t\t\t\t\tFROM pool_offline_data po2\n\t\t\t\t\tWHERE po2.pool_id = ph.id))\nLEFT JOIN pool_update pu on\n\tph.id = pu.hash_id\n\tand pu.id = (SELECT max(pu2.id)\n\t\t\t\t\tFROM pool_update pu2\n\t\t\t\t\tWHERE pu2.hash_id = ph.id)\nLEFT JOIN stake_address sa ON pu.reward_addr_id = sa.id\nLEFT JOIN (\tSELECT ph.id AS poolId, count(bk.id) AS lifetime_blocks\n       \tFROM pool_hash ph\n\t        JOIN slot_leader sl ON sl.pool_hash_id = ph.id\n\t        JOIN block bk ON bk.slot_leader_id = sl.id\n\t        GROUP BY ph.id\t\n\t\t\t) as ltb\n\ton ltb.poolId = ph.id\nWHERE  ph.\"view\" = ''\nExpected results format\n     id   |  pool_name |  pool_ticker |            pool_id                                       |       pool_hash                                               | fixed_cost  |margin | declared_pledge | lifetime_blocks | stake_account \n----------+------------+--------------+----------------------------------------------------------+---------------------------------------------------------------+-------------+-------+-----------------+-----------------+------------------------------------------------------------------\n    463   |  clrPool   |   CLRPL      |  |       | 170,000,000 |  0.1  |  100,000        |                 |  \n(1 rows)","81-gather-various-stake-pool-data#8.1 Gather various stake pool data":"This query gathers data such as pool metadata, stake addresses, and block minting history from various tables.🔎 Here's a breakdown of what the query does:The SELECT ... clause specifies the columns to be included in our results:\nph.id, the id of the pool_hash table\npo.pool_name AS pool_name is the pool's name, retrieved from the pool_offline_data table\npo.ticker_name AS pool_ticker...the pool's ticker symbol.\nph.view AS pool_id...the human-readable pool id.\nph.hash_raw AS pool_hash...the pool's hash value.\npu.fixed_cost...the pool's fixed cost, from pool_update\npu.margin...the pool's margin, also from pool_update\npu.pledge AS declared_pledge...the pool's declared pledge amount.\nltb.lifetime_blocks... the total number of blocks minted by the pool (calculated in the subquery).\nsa.view AS stake_account...the stake address associated with the pool's rewards\nThe FROM pool_hash ph clause specifies that we are selecting data from the pool_hashtable, aliased as ph. This table likely stores core pool identification information.LEFT JOIN pool_offline_data po ON ... performs a left JOIN with the pool_offline_data table. It matches rows based on pool_id and ensures that if multiple entries exist for the same pool, only the latest one is selected (using a subquery to find the maximum id).LEFT JOIN pool_update pu ON ... is another LEFT JOIN, this time with pool_update. It matches on hash_id and again selects the latest update for the pool using a similar subquery approach.LEFT JOIN stake_address sa ON ... is another LEFT JOIN which connects to the stake_address table to retrieve the stake address linked to the pool's rewards.LEFT JOIN (...) AS ltb ON ... incorporates a subquery aliased as ltb. This subquery calculates the total number of blocks minted by the pool by joining pool_hash, slot_leader and block tables and counting the relevant blocks. The result is then joined back to the main query based on poolId.WHERE ph.\"view\" = '' filters the results to include only the data for the specific pool we are interested in.","82-find-out-who-owned-the-stake-pool#8.2 Find out who owned the stake pool":"If you would like to know then the Stake Pool owner account, you could run the following query:\nSELECT\n\tsa.\"view\" AS owner_account\nFROM\n\tpool_hash ph\nJOIN pool_update pu ON\n\tph.id = pu.hash_id\n\tAND pu.id = (SELECT MAX(pu2.id) FROM pool_update pu2 WHERE ph.id = pu2.hash_id)\nJOIN pool_owner po ON\n\tpu.id = po.pool_update_id\nJOIN stake_address sa ON\n\tpo.addr_id = sa.id\nWHERE\n\tph.\"view\" = ''\nExpected results format\n     owner_account\n--------------------------------------------------------------------\n  \n  \n(2 rows)\n🔎 Lets dig a little deeper to gain a better understanding.The opening SELECT sa.\"view\" AS owner_account clause specifies what data the query should return. It selects the view column from the stake_address table (aliased as sa) and labels it as owner_account in the results.FROM pool_hash ph clause means we are inspectig the pool_hash table, giving it the alias ph. This table  stores core information about stake pools, including their unique hashes.JOIN pool_update pu ON ph.id = pu.hash_id performs an INNER JOIN with the pool_update table (aliased as pu).\nThe join condition is ph.id = pu.hash_id, meaning it connects rows from pool_hash and pool_update where their ids match. This links pool information with its update history.AND pu.id = (SELECT MAX(pu2.id) FROM pool_update pu2 WHERE ph.id = pu2.hash_id) is a subquery within the JOIN condition. It ensures that only the latest update for each pool is considered. It finds the maximum id from the pool_update table (using the alias pu2) for the given ph.id and then uses that maximum id to filter the pool_update table in the main query.JOIN pool_owner po ON pu.id = po.pool_update_id is another INNER JOIN with the pool_owner table. It connects based on pu.id = po.pool_update_id, associating the latest pool update with its owner information.JOIN stake_address sa ON po.addr_id = sa.id The final INNER JOIN connects to the stake_address table. The condition po.addr_id = sa.id links the pool owner's information with the actual stake address details.WHERE ph.\"view\" = '' filters the results to include only the data related to the specific pool we provided.","83-list-of-delegators#8.3 List of delegators":"If you are trying to obtain a list of delegators for a specific pool, then you could run the following query:\nSELECT\n\tsa.id AS stakeAddressId,\n\tsa.view AS delegator_address\nFROM stake_address sa\nWHERE sa.id IN (\n\tSELECT dg1.addr_id\n\tFROM delegation dg1\n\tJOIN pool_hash ph ON dg1.pool_hash_id = ph.id\n\tWHERE ph.view = ''\n\tAND NOT EXISTS (\n\t\tSELECT TRUE\n\t\tFROM delegation dg2\n\t\tWHERE dg2.addr_id = dg1.addr_id\n\t\tAND dg2.tx_id > dg1.tx_id\n\t)\n\tAND NOT EXISTS (\n\t\tSELECT TRUE\n\t\tFROM stake_deregistration sd\n\t\tWHERE sd.addr_id = dg1.addr_id\n\t\tAND sd.tx_id > dg1.tx_id\n\t)\n)\nExpected results format\n     stakeaddressid   |  delegator_address                                      \n----------------------+-----------------------------------------------------------\n     10,497\t      |  \n     145,345          | \n(2 rows)\n🔎 Looking closer, lets dissect each line:SELECT sa.id AS stakeAddressId, sa.view AS delegator_address selects the id column (labelling it as stakeAddressId) and the view column (labellting it as delegator_address) from the stake_address table (alias sa). The view column likely represents the human-readable format of the stake address.FROM stake_address sa means we are looking in the stake_address table.WHERE sa.id IN (...) is where we filter by checking if the id from the stake_address table exists within the results of the subquery that follows.The subquery starts with SELECT dg1.addr_id ...selecting the addr_id (stake address id) from the delegation table (alias dg1).FROM delegation dg1 JOIN pool_hash ph ON dg1.pool_hash_id = ph.id joins the delegation table with the pool_hash table based on the pool_hash_id matching in both tables. This connects delegation records with the associated pool information.WHERE ph.view = '' filters the joined results to include only delegations to the specific pool we provided.AND NOT EXISTS (SELECT TRUE FROM delegation dg2 WHERE dg2.addr_id = dg1.addr_id AND dg2.tx_id > dg1.tx_id) ensures that we only consider the latest delegation for each stake address. It checks if there's any other delegation record dg2 for the same addr_id but with a higher tx_id (ie. a later transaction). If such a record exists, it excludes the current delegation dg1 from the results.Similarly, the AND NOT EXISTS (SELECT TRUE FROM stake_deregistration sd WHERE sd.addr_id = dg1.addr_id AND sd.tx_id > dg1.tx_id) clause checks if there's a stake deregistration record sd for the same addr_id with a higher tx_id. If so, it means the stake address has been deregistered after the delegation, so it's excluded from the results.","summary#Summary":"Our first query, 3.1, inspects several tables to return various data on our specific stake pool. Query 3.2 traverses through several tables to pinpoint the owner's stake address for a particular pool. Finally, 3.3 queries the Ledger Sync database schema to return a list of current delegators for the stake pool address we provide."}},"/use-cases/WalletQueries/wallet09":{"title":"Wallet09","data":{"9-stake-pool-lifetime-blocks#9. Stake pool lifetime blocks":"The \"Lifetime Blocks\" of a stake pool refers to the total number of blocks that the stake pool has successfully produced over its entire operational history. This metric provides insight into the pool's performance and reliability, reflecting its ability to contribute to the Cardano blockchain by creating blocks. Here is how you can fetch this information.\nSELECT ph.view , bk.hash as block_hash, bk.epoch_no, ROW_NUMBER() OVER (ORDER BY bk.epoch_no)\n            FROM pool_hash ph\n            JOIN slot_leader sl ON sl.pool_hash_id = ph.id\n            JOIN block bk ON bk.slot_leader_id = sl.id\n            WHERE ph.view = ''\nExpected results format\n     view                                                |      block_hash\t\t                                             |  epoch_no |  epoch_no \n---------------------------------------------------------+-------------------------------------------------------------------+-----------+---------- \n |   |   121     |   1              \n |   |   121\t |   2\n |   |   121\t |   3\n   ............\n(Note: full results trimmed for readability)\nIn this SQL query, we retrieve information about blocks associated with a specific pool hash by joining multiple tables. Let's take a closer look at what the query does. 🔎","selecting-the-right-info#'SELECT'ing the right info":"SELECT clause retrieves the following data:\nph.view selects the unique identifier, or 'view', of the stake pool.\nbk.hash as block_hash selects the unique hash identifier of each block.\nbk.epoch_no selects the epoch number in which the block was created.\nROW_NUMBER() OVER (ORDER BY bk.epoch_no) assigns a sequential row number to each block, starting from 1, and then ordered chronologically by epoch number. This tracks the order in which the stake pool created blocks over time.","from-pool_hash-ph#FROM pool_hash ph":"Looks in the table pool_hash, which stores information about stake pools, and assigns it the alias ph.","join-slot_leader-sl-on-slpool_hash_id--phid#JOIN slot_leader sl ON sl.pool_hash_id = ph.id":"Joins the pool_hash table with the slot_leader table. The connection is made based on the matching id from pool_hash and pool_hash_id from slot_leader. The slot_leader table provides us with information about which stake pool was selected to lead a particular slot and potentially create a block.","join-block-bk-on-bkslot_leader_id--slid#JOIN block bk ON bk.slot_leader_id = sl.id":"Joins the result of the previous join with the block table. The connection is based on matching the id from slot_leader with slot_leader_id from block. The block table stores detailed information about each block on the blockchain.","where-phview--pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38#WHERE ph.view = 'pool12dd0mg935mzx6rdaykngqj8aeqxrtjltg5jtdccrt7p0x78rc38'":"This `WHERE' clause restricts the results to only show blocks created by the stake pool with the specific view id we give the query.","summary#Summary":"The query returns a result set containing:\nThe stake pool's view id.\nThe unique hash of each block created by the stake pool.\nThe epoch number of each block.\nA row number indicating the chronological order of block creation.\n🔎  You can also verify the details on one of many Cardano community explorers listed here. For this one, lets use Cardanoscan 🎯"}},"/use-cases/WalletQueries/wallet10":{"title":"Wallet10","data":{"10-list-the-current-dreps#10. List the current dReps":"Another important feature Cardano Blockchain implements is governance, where the goal is put decision-making on chain, and in the hands of the community. To read more about the CIP-1694 roadmap here, visit or catch up on the latest news on Cardano Forum.This query provides a list of dReps currently registered on the system and additional information including:\ndRep ID\ntx_id of the registration\ncert index\ntype\ndeposit\nhash of the pool which we it is delegating to\ncredential type\nanchor URL\nanchor hash\ndRep status (active / inactive)\nregistration date\nepoch\nblock\nslot\nnumber of delegators\nThis information helps you understand who is voting on proposals and shaping the future of the Cardano ecosystem. Note that we are using the Sanchonet network for this query, which queries the same database schema as mainnet.\nselect\n    dr.drep_id AS drepId,\n    dr.drep_hash AS drepHash,\n    dr.tx_hash AS tx_id,\n    dr.cert_index AS cert_index,\n    dr.\"type\" AS \"type\",\n    dr.deposit AS deposit,\n    dr.cred_type AS credential_type,\n    dr.anchor_url AS anchor_url,\n    dr.anchor_hash AS anchor_hash,\n    CASE\n\t    WHEN COALESCE(vp.epoch, 0)\n\t    \t+ (SELECT COALESCE(ep.drep_activity, 0) FROM epoch_param ep ORDER BY ep.epoch_no DESC LIMIT 1) \n\t    \t< (SELECT COALESCE(ep.epoch_no, 0) FROM epoch_param ep ORDER BY ep.epoch_no DESC LIMIT 1)\n\t    \tTHEN 'INACTIVE'\n\t    WHEN dr.\"type\" = 'UNREG_DREP_CERT'\n\t    \tTHEN 'RETIRED'\n\t    ELSE 'ACTIVE'\n\tEND AS dRep_status,\n    to_timestamp(sub2.block_time) at TIME zone 'UTC' as registration_date,\n    dr.epoch AS epoch,\n\tdr.block AS block,\n\tdr.slot AS slot,\n    coalesce (sub3.delegators_count, 0) as number_of_delegators\nFROM drep_registration dr\nJOIN (SELECT\n\t        max(slot) AS max_slot,\n\t        dr.drep_hash\n\t  FROM drep_registration dr\n\t  GROUP BY dr.drep_hash    \n\t ) AS sub1 \nON  dr.drep_hash = sub1.drep_hash\n    and dr.slot = sub1.max_slot\nJOIN (\tSELECT\n\t        max(block_time) as block_time ,\n\t        dr.drep_hash\n\t    FROM drep_registration dr\n\t    WHERE dr.\"type\" = 'REG_DREP_CERT'\n\t    GROUP BY dr.drep_hash\n\t\t) AS sub2\nON dr.drep_hash = sub2.drep_hash\nLEFT JOIN ( SELECT\n\t\t        count(DISTINCT(d.address)) as delegators_count,\n\t\t        d.drep_hash\n\t\t    FROM delegation_vote d\n\t\t    WHERE d.drep_hash is not null\n\t\t    GROUP BY drep_hash\n\t\t\t) AS sub3\nON dr.drep_hash = sub3.drep_hash\nLEFT JOIN (\tSELECT voter_hash, max(epoch) AS epoch, max(slot) \n\t\t\tFROM voting_procedure \n\t\t\tGROUP BY voter_hash\n\t\t\t) vp ON vp.voter_hash = dr.drep_hash\nExpected results format\ndrepid   | drephash| tx_id    | cert_index | type        | deposit | credential_type | anchor_url      | anchor_hash | drep_status | registration_date | epoch | block | slot   | number_of_delegators\n---------+---------+----------+------------+-------------+---------+-----------------+-----------------+-------------+-------------+-------------------+-------+-------+--------+--------------------- \ndrep1..n | 0ae..d50| 3fd..7a20| 6          |REG_DREP_CERT|500000000| ADDR_KEYHASH    | https://bit..2HL|  1..111     |    INACTIVE |  2024-08-01 16:56 | 413   |1784176|35742397| 0\n(Note: full results trimmed for readability)\nLet's take a closer look at what the query does. 🔎","main-select-clause#Main SELECT Clause":"SELECTs various columns from the drep_registration table (alias dr) such as drep_id, drep_hash, tx_id, cert_index, type, deposit, cred_type, anchor_url, anchor_hash, epoch, block, and slot.","case-statement-for-drep_status#CASE Statement for dRep_status":"Calculates the dRep_status based on the following logic:\nINACTIVE...If the sum of vp.epoch (from the voting_procedure table) and the latest drep_activity from epoch_param is less than the latest epoch_n from epoch_param. This likely indicates the dRep hasn't been active in recent epochs.\nRETIRED If the type in drep_registration is UNREG_DREP_CERT, meaning the dRep has been unregistered.\nACTIVE... otherwise, the dRep is considered active.","registration_date-calculation#registration_date Calculation":"Converts the block_time (from the drep_registration table) to a timestamp with UTC timezone.\nThe subquery sub2 fetches the maximum block_time for each drep_hash where the type is 'REG_DREP_CERT' (registration certificate).","number_of_delegators-calculation#number_of_delegators Calculation":"Uses a LEFT JOIN with a subquery sub3 to count the number of distinct delegators address associated with each drep_hash in the delegation_vote table. COALESCE ensures that if there are no delegators, the count is shown as 0.","joins-and-subqueries#Joins and Subqueries":"JOIN with sub1 ensures only the latest registration entry for each drep_hash is considered (based on the maximum slot).\nLEFT JOIN with sub3 and vp brings in the delegators count and latest voting epoch information for each dRep."}},"/use-cases/WalletQueries/wallet11":{"title":"Wallet11","data":{"11-find-active-governance-proposals#11. Find Active Governance Proposals":"To better understand ongoing governance activities in the Cardano ecosystem and gauge community support for each proposal, let's fetch a list of active governance proposals along with relevant details, such as:\nproposal tx_id\nindex\ndeposit\nreturned address\nanchor URL\nanchor hash\ntype (one of the 7 governance actions)\ndetails\nepoch\nslot\nblock\ntimestamp\nnumber of yes/no/abstain\nNote: Again, we will use the Sanchonet network for this query.\nSELECT \tgap.tx_hash AS tx_id,\n\t\tgap.idx AS \"index\",\n\t\tgap.deposit AS deposit,\n\t\tgap.return_address AS returned_address,\n\t\tgap.anchor_url AS anchor_url,\n\t\tgap.anchor_hash AS anchor_hash,\n\t\tgap.\"type\" AS \"type\",\n\t\tgap.details AS details,\n\t\tgap.epoch AS epoch,\n\t\tgap.slot AS slot,\n\t\tgap.block AS block,\n\t\tgap.update_datetime AS time_stamp,\n\t\t(CASE WHEN voting.yes_vote IS NULL THEN 0 ELSE voting.yes_vote END) AS yes_vote,\n\t\t(CASE WHEN voting.no_vote IS NULL THEN 0 ELSE voting.no_vote END) AS no_vote,\n\t\t(CASE WHEN voting.abstain_vote IS NULL THEN 0 ELSE voting.abstain_vote END) AS abstain_vote\n\t\t\tFROM gov_action_proposal gap\n\t\t\tLEFT JOIN (SELECT \tlistVote.gov_action_tx_hash AS gov_action_tx_hash,\n\t\t\t\t\t\tlistVote.gov_action_index AS gov_action_index,\n\t\t\t\t\t\tsum(CASE WHEN listVote.vote = 'YES' THEN 1 ELSE 0 END) AS yes_vote,\n\t\t\t\t\t\tsum(CASE WHEN listVote.vote = 'NO' THEN 1 ELSE 0 END) AS no_vote,\n\t\t\t\t\t\tsum(CASE WHEN listVote.vote = 'ABSTAIN' THEN 1 ELSE 0 END) AS abstain_vote\n\t\t\t\tFROM (\tSELECT voter_hash, gov_action_tx_hash, gov_action_index, vote, \n\t\t\t\t\t\tROW_NUMBER() OVER (PARTITION BY voter_hash, gov_action_tx_hash, gov_action_index ORDER BY slot DESC) AS rank_slot\n\t\t\t\tFROM voting_procedure vp \n\t\t\t\t\t\t) AS listVote\n\t\t\t\tWHERE rank_slot = 1\t\t\t\n\t\t\t        GROUP BY listVote.gov_action_tx_hash, listVote.gov_action_index\n\t\t\t\t) AS voting ON voting.gov_action_tx_hash = gap.tx_hash AND voting.gov_action_index = gap.idx\n\t\t\tWHERE \n\t\t\t\tCOALESCE(gap.epoch, 0) \n\t\t\t\t+ \n\t\t\t\t(SELECT COALESCE(ep.gov_action_lifetime, 0) FROM epoch_param ep\n\t\t\t\t\tORDER BY ep.epoch_no DESC LIMIT 1)\n\t\t\t\t>= \n\t\t\t\t(SELECT COALESCE(ep.epoch_no, 0) FROM epoch_param ep\n\t\t\t\t    ORDER BY ep.epoch_no DESC LIMIT 1)\nExpected results format\ntx_id      | index| deposit        | returned_address     | anchor_url                                | anchor_hash | type                   | details                | epoch | slot       | block     | time_stamp      | yes_vote | no_vote | abstain_vote\n-----------+------+----------------+----------------------+-------------------------------------------+-------------+------------------------+------------------------+-------+------------+-----------+-----------------+----------+---------+------------- \nb71b...e3a | 0    | 100,000,000,000| stake_test1up...2r5a | https://thc-room335.com/poolMetaData.json | 6dd6...755  | INFO_ACTION            | {\"type\": \"INFO_ACTION\"}| 406   | 35,115,090 | 1,754,277 |2024-08-07 10:07 |     0    |    0    |       0\n(Note: full results trimmed for readability)\n🔎  Here's a breakdown of what the query does:","proposal-information-retrieval#Proposal Information Retrieval":"The primary focus of the query is to fetch data from the gov_action_proposal table (alias gap). This returns details like:\ntx_hash ...the unique transaction identifier associated with the proposal.\nidx ...an index within the transaction.\ndeposit, return_address, anchor_url, anchor_hash ...proposal-specific metadata.\ntype, details...the nature of the proposal and additional descriptive text.\nepoch, slot, block...information about when the proposal was made.\nupdate_datetime ...the last time this record was modified in the database.","voting-data-aggregation#Voting Data Aggregation":"The subquery aliased as voting calculates the yes_vote, no_vote, and abstain_vote counts for each proposal. It does this by checking the voting_procedure table, filtering for the latest vote from each voter on each proposal (using ROW_NUMBER() and rank_slot = 1). It then groups the results by gov_action_tx_hash and gov_action_index to get totals per proposal.","joining-proposal-and-voting-data#Joining Proposal and Voting Data":"A LEFT JOIN combines the proposal information with the calculated vote counts. This ensures that even proposals without any votes are included in the output, with their vote counts shown as 0.","filtering-active-proposals#Filtering Active Proposals":"The WHERE clause filters the results to only include proposals that are still considered \"active\" based on:\nThe proposal's epoch, when it was made.\nThe latest gov_action_lifetime parameter from the epoch_param table, ie. how long proposals remain active.\nThe latest epoch_no from the epoch_param table, ie. the current epoch."}},"/use-cases/WalletQueries/wallet12":{"title":"Wallet12","data":{"12-smart-contract-transaction-data#12. Smart contract transaction data":"For our final query, we will inspect the details of a specific transaction, namely, the transaction id . Note we are not modifying the blockchain in any way, we are just reading data from it.\nFor most users, the wallet is their gateway when interacting with dApps (decentralized applications) on Cardano. There is even a CIP-30 outlining a consistent standard for developers to follow. For example, when a user swaps a token on a dApp, the wallet securely signs the transaction, and this transaction typically triggers smart contract(s). Most smart contracts on Cardano are written in Aiken. To learn more, head over to aiken-lang.org where you will find some excellent primers and guides. Learn how Aiken's compiler and standard library enforce safe patterns to aid in secure code. Add to that a full-blown property test framework, you can be confident Aiken is fully equipped for high assurance.\n🔎  As usual, you can also take a closer look using the Cardano Explorer","121-transaction-information#12.1 Transaction information":"Let's start by retrieving the transaction details:\ntransaction hash\ntimestamp\nblock\nfee\nepoch\nslot\nsource address\ndestination address\nassets\namount\nUTXOs used\nSELECT tx_detail.* FROM (\n\tSELECT \n\t\t'destination_address' AS direction,\n\t\ttx.hash AS txhash,\n\t\ttx_out.address AS address,\n\t\tsa.\"view\" AS stake_address,\n\t\ttx_out.value AS ADA_amount,\n\t\tma.name AS asset_name,\n\t\tsum(mto.quantity) AS quantity,\n\t\tb.time AS time_stamp,\n\t\ttx.fee AS transaction_fee,\n\t\tb.block_no AS block,\n\t\tb.slot_no AS slot,\n\t\tb.epoch_no AS epoch,\n\t\tNULL AS utxo\n\tFROM tx\n\t\tLEFT JOIN tx_out ON tx_out.tx_id = tx.id\n\t\tLEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id\n\t\tLEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id\n\t\tLEFT JOIN multi_asset ma ON ma.id = mto.ident\n\t\tLEFT JOIN block b ON b.id = tx.block_id\n\tWHERE\n\t\ttx.hash = ''\n\tGROUP BY direction, txhash, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, epoch, utxo\n\tUNION ALL\n\t\tSELECT \n\t\t\t'source_address' AS direction,\n\t\t\ttx.hash AS txhash,\n\t\t\ttx_out.address AS address,\n\t\t\tsa.\"view\" AS stake_address,\t\t\t\t\n\t\t\ttx_out.value ADA_amount,\n\t\t\tma.name AS asset_name,\n\t\t\tsum(mto.quantity) AS quantity,\n\t\t\tb.time AS time_stamp,\n\t\t\ttx.fee AS transaction_fee,\n\t\t\tb.block_no AS block,\n\t\t\tb.slot_no AS slot,\n\t\t\tb.epoch_no AS epoch,\n\t\t\ttxin.hash AS utxo\n\tFROM tx\n\t\tLEFT JOIN tx_in ti ON ti.tx_in_id = tx.id\n\t\tLEFT JOIN tx_out ON tx_out.tx_id = ti.tx_out_id AND tx_out.\"index\" = ti.tx_out_index \n\t\tLEFT JOIN tx txin ON txin.id = tx_out.tx_id\n\t\tLEFT JOIN stake_address sa ON sa.id = tx_out.stake_address_id\n\t\tLEFT JOIN ma_tx_out mto ON mto.tx_out_id = tx_out.id\n\t\tLEFT JOIN multi_asset ma ON ma.id = mto.ident\n\t\tLEFT JOIN block b ON b.id = tx.block_id\n\tWHERE\n\t\ttx.hash = ''\t\t\t\n\tGROUP BY direction, txhash, address, stake_address, ADA_amount, asset_name, time_stamp, transaction_fee, block, slot, epoch, utxo\n\t\t\t\t) AS tx_detail\n\tORDER BY tx_detail.direction ASC\nExpected results format\ndirection           |  txhash            |  address              | stake_address              |ada_amount|asset_name|quantity|time_stamp\t     |tx_fee |block     | slot      |epoch|utxo\n--------------------+--------------------+-----------------------+----------------------------+----------+----------+--------+-------------------+------------------+-----------+-----+----------\ndestination_address | 52385f2dd....ebb57 |addr1q94ga....grqd9dw0d|stake1u9d9...sapektypsmfx9qr|20,000,000|          |        |2024-07-13 15:33:54|395,771|10,568,064|129,318,543| 496 | \t \nsource_address      | 52385f2dd....ebb57 |addr1qyvl8....vgsyxh7q9|stake1uxw4...8f43pxkyg5842yn|33,080,297|          |        |2024-07-13 15:33:54|395,771|10,568,064|129,318,543| 496 |9d8...57a\n(Note: full results trimmed for readability)\n🔎 Let's zoom in to see what the query does step-by-step:","overall-query-structure#Overall query structure":"To find the information we need, the query focuses on two perspectives:\nDestination Addresses: Where did the funds/assets end up?\nSource Addresses: Where did the funds/assets come from?\nUNION ALL combines the results from the two separate SELECT statements. Each SELECT statement targets one of the perspectives above.","destination-addresses-the-first-select#Destination Addresses, the first SELECT":"It fetches details about the outputs tx_out of the transaction. It then links to other tables to fetch further information such as:\nStake address associated with the output\nAsset names and quantities\nBlock, slot, and epoch details of the transaction\nTransaction fee","source-addresses-the-second-select#Source Addresses, the second SELECT":"This SELECT statement looks back to the inputs tx_in of the transaction. It traces the chain of transactions to find the original outputs tx_out that were spent as inputs in this transaction. It retrieves similar information as the first SELECT, but additionally includes the 'utxo' (unspent transaction output) hash which represents the specific output that was spent.","result-returned#Result returned":"The two result sets are combined with a UNION ALL clause, and the final output is sorted by direction so that destination_address rows appear before source_address rows in the results.","122-contracts-details#12.2 Contracts details":"For this query, we are looking for the Redeemer, datum hash and datum associated with the transaction. A good recap on there terms is available on Aiken-lang.org.\nSELECT \n\tre.script_hash AS scriptHash, \n\ttxOut.address AS address, \n\tre.purpose as purpose,\n        encode(rd.bytes, 'hex') as redeemerData, \n        re.unit_mem as redeemerMem, \n        re.unit_steps as redeemerSteps,\n        d.hash as datumHash, \n        encode(d.bytes, 'hex') as datum\n           FROM tx\n           INNER JOIN redeemer re ON re.tx_id = tx.id \n           LEFT JOIN redeemer_data rd ON re.redeemer_data_id = rd.id \n           LEFT JOIN tx_in txIn ON (txIn.redeemer_id = re.id and txIn.tx_in_id = tx.id)\n           LEFT JOIN tx_out txOut ON txIn.tx_out_id = txOut.tx_id AND txIn.tx_out_index = txOut.index\n           LEFT JOIN datum d ON (txOut.data_hash = d.hash OR txOut.inline_datum_id = d.id)\n           WHERE tx.hash = ''\nExpected results format\nscripthash    | address      |purpose|redeemerbytes| redeemermem| redeemersteps\t | datumhash         | datumbytes\n--------------+--------------+-------+-------------+------------+----------------+-------------------+------------------------\n9068...ce138ad|addr1zx...5plm|spend  |d87a80       | 2,463,014  |  689,900,093\t | 3c27703297...1fce | d8799f581c...00ffffffff\n(Note: full results trimmed for readability)\n🔎 Let's zoom in to see what the query does step-by-step:","target-transaction#Target transaction":"WHERE tx.hash = '...' filters to the specific transaction we are interested in.","redeemer-details#Redeemer details":"INNER JOIN redeemer re ON re.tx_id = tx.id ensures we only consider redeemers associated with the target transaction. re.script_hash, re.purpose, re.unit_mem, re.unit_steps fetch the script hash the redeemer interacts with, its purpose, memory usage, and computational steps, respectively.","redeemer-data#Redeemer Data":"LEFT JOIN redeemer_data rd ON re.redeemer_data_id = rd.id brings in redeemer data if it exists. encode(rd.bytes, 'hex') as redeemerData converts the raw redeemer data into a human-readable hexadecimal format.","transaction-input-and-output-join#Transaction input and output JOIN":"LEFT JOIN tx_in txIn ON ... joins the transaction input that triggered the redeemer to the transaction itself. LEFT JOIN tx_out txOut ON ... links this input with the specific transaction output it spends from. txOut.address extracts the address of the output being spent.","datum-information#Datum information":"LEFT JOIN datum d ON ... attempts to find a datum linked to the spent output, either through a hash reference or an inline datum.\nd.hash and encode(d.bytes, 'hex') as datum provide the datum hash and its hexadecimal representation.","output#Output":"The query will produce a result set containing:\nscriptHash ...the script hash the redeemer interacts with.\naddress...the address of the UTxO spent by the transaction input.\npurpose...the purpose of the redeemer\nredeemerData...the Hex-encoded redeemer data (if present).\nredeemerMem & redeemerSteps...the redeemer's memory & computational step usage.\ndatumHash...the hash of the datum associated with the spent output.\ndatum ...the hex-encoded datum content (if present).\nRemember you can also review the results in any Cardano explorer.  The Cardano Developer Portal has compiled a list in their 'Showcase' section. For example, you can review review the results of Queries 12.1 and 12.2 at this link 🔎","123-collateral-input--output#12.3 Collateral input & output":"The collateral mechanism is an important feature that has been designed to ensure successful smart contract execution. You can read more about it in the documentation.This query retrieves information about the inputs and outputs associated with our transaction, identified by its hash . The inputs and outputs are categorized in the results in the 'collateral' column.\n\t   SELECT \n\t\t'input' AS collateral,\n\t       \ttxOut.address AS address, \n             \ttxOut.value AS value,\n             \ttxOut.index AS index\n           FROM unconsume_tx_in cti \n           INNER JOIN tx_out txOut on txOut.tx_id = cti.tx_out_id and txOut.index = cti.tx_out_index \n           LEFT JOIN tx ON cti.tx_in_id = tx.id \n           JOIN tx txin ON cti.tx_out_id = txin.id \n           WHERE \n\t\ttx.hash  = ''\n           \n           UNION\n          \n           SELECT \n\t\t   'output' AS collateral,\n\t           failedTxOut.address AS address, \n\t           failedTxOut.value AS value,\n\t           failedTxOut.index AS index\n           FROM failed_tx_out failedTxOut \n           INNER JOIN tx ON failedTxOut.tx_id = tx.id\n           WHERE tx.hash = ''\nExpected results format\ncollateral | address      \t\t\t\t\t\t\t\t\t\t\t    \t\t\t\t\t\t\t\t\t\t\t |value       |index\n-----------+---------------------------------------------------------------------------------------------------------+------------+-----\ninput      |  | 33,080,297 | 0\noutput     |  | 32,486,640 | 5\n🔎 Let's zoom in to see what the query does step-by-step:","first-select#First SELECT":"The FROM unconsume_tx_in cti clause starts by looking at unspent transaction outputs (UTXOs) that have been used as inputs in some other transaction. The INNER JOIN tx_out txOut ... joins with the tx_out table to get details about these UTXOs, ie. address, value, index within the transaction.The LEFT JOIN tx ON ... attempts to join with the tx table to see if there's a transaction where this UTXO was used as an input.The JOIN tx txin ON ... clause also joins with the tx table again (alias txin) to get details about the transaction where this UTXO was originally created as an output.The WHERE tx.hash = ... clause filters the results to only include UTXOs that were used as inputs in the specific transaction we specified. The 'input' AS collateral clause labels these results as 'input' in the collateral column.","second-select#Second SELECT":"The FROM failed_tx_out failedTxOut looks at outputs from transactions that failed. The INNER JOIN tx ON ... clause joins with the tx table to get details about the failed transaction.The WHERE tx.hash = ... clause filters the results to only include outputs from the specific failed transaction we're interested in. The 'output' AS collateral clause labels these results as 'output' in the collateral column.","union#UNION":"The UNION clause combines the results from the two parts into a single result set:\ncollateral indicates whether the row represents a transaction input or an output\naddress ...ie, the address associated with the input or output\nvalue is the amount of ADA (or other assets) associated with the input or output\nindex tells us the position of the input or output within its transaction","124-reference-input-and-contract-reference#12.4 Reference input and contract reference":"Our final query aims to retrieve details about the outputs (UTXOs) that were spent as inputs in our specific transaction, identified by its hash .\n\t  SELECT \n  \t\ttxOut.address as address,\n     \t\ttx.hash as txHash, \n      \t\ttxOut.value as value, \n      \t\tr.tx_out_index as index\n           FROM reference_tx_in r\n           JOIN tx_out txOut ON r.tx_out_id = txOut.tx_id AND txOut.index = r.tx_out_index\n           JOIN tx ON txOut.tx_id = tx.id \n\t   JOIN tx txin ON txin.id = r.tx_in_id \n           WHERE \n\t\ttxin.hash = ''\nExpected results format\naddress \t\t\t\t\t\t\t\t \t                        \t\t\t\t\t\t\t\t\t| txhash      \t\t\t|value       |index\n--------------------------------------------------------------------------------------------------------+-----------------------+------------+-----\n\t| 9a3245....b0fc1d06f5b | 40,000,000 | 0\n(Note:  results abbreviated for readability)\n🔎 Let's zoom in to see what the query does step-by-step:","query-structure#Query structure":"The FROM reference_tx_in r starts by looking at the reference_tx_in table, which stores information about transaction inputs and the UTXOs they reference.JOIN tx_out txOut ON ...  joins with the tx_out table to get details about these UTXOs, ie. address, value, index within the transaction.JOIN tx ON txOut.tx_id = tx.id joins with the tx table to get information about the transaction where these UTXOs were created as outputs.JOIN tx txin ON txin.id = r.tx_in_id joins with the tx table again (aliase txin) to get details about the transaction where these UTXOs were spent as inputs.The WHERE txin.hash = ... clause filters the results to only include UTXOs that were spent as inputs in the specific transaction we're interested in.","results#Results":"address is the address associated with the spent UTXO\ntxHash is the hash of the transaction where this UTXO was created as an output\nvalue is the amount of ADA (or other assets) associated with the spent UTXO\nindex is the position of the UTXO within the transaction where it was created"}},"/use-cases/nftqueries":{"title":"NFT Marketplace","data":{"":"Ledger Sync can provide developers with the necessary data they need to build their own NFT marketplace, or to enable the dApps to interact with the Marketplace through relevant queries. We will outline some common queries in this tutorial🔎 You can verify results using any of the community explorers listed here."}},"/use-cases/nftqueries/nft1":{"title":"Nft1","data":{"1-view-collections#1. View Collections":"NFT stands for non-fungible token. It is intended to be a unique token as in one and only one ever will be minted and no other token is then comparably equivalent to it. For this first query, we aim to find mint transactions with the label 721 in the metadata of the token. The 721 tag refers to the original standard for NFTs on Cardano as defined in CIP-25.Our query will return NFTs (label 721) collections in Cardano with their respective:\nasset collection name,\npolicy ID\ntotal supply\ncreation date\nRemember you can also query the blockchain for this data using an explorer such as cexplorer\nSELECT\n\tma.\"policy\" AS policy_id,\n\tmin(ma.time) AS creation_time,\n\tsum(mtm.quantity)  AS total_supply\nFROM \n   \tmulti_asset ma\nLEFT JOIN \n    \tma_tx_mint mtm ON ma.id = mtm.ident\nLEFT JOIN \n\t(SELECT tm.tx_id AS txid FROM tx_metadata tm \n\t\tWHERE tm.\"key\" = 721\n\t\t) AS tm ON tm.txid = mtm.tx_id\nGROUP BY ma.\"policy\"\nLIMIT 200\nExpected results format\npolicy_id                                                | creation_time             | total_supply\t\t\n---------------------------------------------------------+---------------------------+-------------\n | 2021-03-01 21:47:37.000   | 1\n | 2023-06-22 00:28:48.000   | 2\n | 2021-06-25 01:20:11.000   | 1\n | 2021-07-22 00:00:26.000   | 48\n | 2022-04-04 21:22:31.000   | 21\n        ....                                             |  ....                     | ....\n(Note: results trimmed for readability) \n             \n🔎 Let's take a closer look at each part of the query.We are looking (SELECT'ing) from the following tables:multi_asset (ma): This table stores information about all the different tokens or assets on Cardano. Each asset is uniquely identified by a combination of policy (the policy ID under which the asset was minted) and id (a unique identifier within that policy).ma_tx_mint (mtm): This table tracks the minting (creation) transactions of assets. It links to the multi_asset table using ident, and also stores information about the quantity minted in each transaction.tx_metadata (tm): This table holds additional metadata associated with transactions, and for this query, we are filtering on metadata with the key '721'.LEFT JOIN ma_tx_mint ON ... joins the asset information (multi_asset) with its minting transactions (ma_tx_mint). The LEFT JOIN ensures that even assets that have not been minted are included in the result, but their total_supply will be NULL.LEFT JOIN (SELECT ... FROM tx_metadata) AS tm ON ... is a subquery that filters tx_metadata to only include rows where the metadata key is 721.  The result of this subquery is then joined with the previous result, effectively filtering out assets that are not associated with transactions containing this specific metadata.GROUP BY ma.\"policy\" groups the results by the policy (policy ID), meaning it will calculate the total_supply and find the earliest creation_time for each unique policy.The SELECT ... clause selects the policy_id, the earliest creation_time for that policy, and the total_supply (sum of quantities minted across all transactions for that policy).LIMIT 200 limits the output to the first 200 policies."}},"/use-cases/nftqueries/nft2":{"title":"Nft2","data":{"2-viewing-nft-collection-details#2. Viewing NFT collection details":"Now we will get more granular by quering for the data for a specif NFT collection. We'll search for details on Spacebudz, which made history by being the very first NFT collection minted on Cardano in March 2021.","21-query-the-policy-id#2.1 Query the policy id":"The policy ID is the unique identifier associated with a specific minting policy. The policy outlines the rules that govern the minting (and potentially the burning) of native assets on Cardano. Each minting policy has its own distinct policy ID, generated from the policy script itself. This ensures that tokens minted under different policies are easily distinguishable, even if they have the same name or other various attributes. Once a native asset is minted, it is inextricably linked to its corresponding policy ID. This connection is crucial for tracking the origin and legitimacy of tokens on Cardano.So for this query, from the policy ID , we will fetch:\nThe total number of assets in the collection.\nThe number of transactions involving assets from the collection within the last 24 hours.\nSELECT \n\t\tma.\"policy\" AS collection_policy,\n\t\tcount(*) AS number_of_assets,\n\t\t(SELECT \n\t\t\tcount(DISTINCT tx.id) AS transaction_count_24h\n\t\t\tFROM tx\n\t\t\tJOIN block b ON b.id = tx.block_id \n\t\t\tJOIN tx_out to2 ON to2.tx_id = tx.id \n\t\t\tJOIN ma_tx_out mto ON to2.id = mto.tx_out_id\n\t\t\tJOIN multi_asset ma ON mto.ident = ma.id\n\t\tWHERE\n\t\t\tma.policy = ''\n\t\t\t    AND b.\"time\" > (now() at time zone 'utc') - INTERVAL '24 hours'\n\t\t\t) AS number_of_tx_in_24h\n\t\tFROM \n\t\t        multi_asset ma\n\t\tWHERE \n\t\t        ma.policy = ''\n\t\tGROUP BY ma.\"policy\"\nExpected results format\ncollection_policy                                        | number_of_assets | number_of_tx_in_24h\n---------------------------------------------------------+------------------+----------------------\n |    10,000        | 75 \n             \n🔎 Let's take a closer look at each part of the query.FROM multi_asset ma specifies that the query will be looking at the multi_asset table, which stores information about assets on the Cardano blockchain.\nWHERE ma.policy = '...' This filters the results to only include assets that belong to the collection identified by the policy ID we provided.\nGROUP BY ma.\"policy\"  groups the results by the policy ID, ensuring that we get a single row summarizing the information for the entire collection.Within the SELECT clause, ma.\"policy\" AS collection_policy selects the policy ID of the collection and labels it as collection_policy. count(*) AS number_of_assetscounts the number of rows (i.e., assets) in the filtered result set and labels it as number_of_assets.The subquery is used to calculate the number of transactions involving assets from this collection within the last 24 hours.\nFROM tx JOIN block b ON b.id = tx.block_id JOIN tx_out to2 ON to2.tx_id = tx.id JOIN ma_tx_out mto ON to2.id = mto.tx_out_id JOIN multi_asset ma ON mto.ident = ma.id joins several tables to link transactions (tx), blocks (block), transaction outputs (tx_out), and multi-asset information (multi_asset) together.The WHERE ma.policy = '...' AND b.\"time\" > (now() at time zone 'utc') - INTERVAL '1 days' clause filters the results to only include transactions involving assets from the specified collection that occurred within the last 24 hours.\nSELECT count(DISTINCT tx.id) AS transaction_count_24h counts the number of distinct transaction IDs in the filtered result set and labels it as transaction_count_24h.","22-asset-details#2.2 Asset details":"This next query lists all assets/NFTs belonging to the Spacebudz collection with their respective:\nasset name\nencoded name\nAsset ID\nminting (creation) date\nSELECT\n\t\tma.name_view AS asset_name,\n\t\tencode(ma.name, 'hex') AS encoded_name,\n\t\tma.fingerprint AS Asset_ID,\n\t\tma.\"time\" AS creation_date\n\tFROM multi_asset ma \n\tWHERE ma.\"policy\" = ''\nExpected results format\nasset_name   |  encoded_name             |  asset_id                                     | creation_date\n-------------+---------------------------+-----------------------------------------------+-------------------------\nSpaceBud9007 | \t537061636542756439303037 | asset1qqcka5xwrzx40t7gaf2l4qd0k8latxqpkpq28h  | 2021-03-24 01:18:08.000\nSpaceBud5511 | \t537061636542756435353131 | asset1x0pkcc6vf2v5ezhhj4hd9mls3pwwufvxy66rwp  | 2021-03-24 01:22:10.000\n  ....       | \t....                     | \t......                                   | \t...\n(Note: results trimmed for readability)             \n🔎 Let's take a closer look at each part of the query.FROM multi_asset ma indicates that the query is targeting the multi_asset table, which stores information about assets (including NFTs) on Cardano. WHERE ma.\"policy\" = '' filters the results to only include assets that belong to the specific collection (Policy ID) we are interested in.SELECT:\nma.name_view AS asset_name retrieves the human-readable name of the asset and labels it as asset_name.encode(ma.name, 'hex') AS encoded_name takes the raw asset name data ma.name, encodes it into a hexadecimal string representation, and labels it as encoded_name. ma.fingerprint AS Asset_ID selects the unique fingerprint (identifier) of the asset and labels it as Asset_ID.ma.\"time\" AS creation_date retrieves the timestamp when the asset was created and labels it as creation_date.","23-querying-a-specific-nft#2.3 Querying a specific NFT":"Our last query fetches the following data about a specific NFT:\nasset name\nencoded name\nasset metadata\nowner (wallet address)\nmint date\nSELECT \n\tma.name_view AS asset_name,\n\tencode(ma.name, 'hex') AS encoded_name,\n\t(SELECT tm.json FROM tx\n               JOIN ma_tx_mint mtm ON mtm.tx_id = tx.id \n               JOIN tx_metadata tm ON tm.tx_id = tx.id\n               JOIN multi_asset ma ON ma.id = mtm.ident\n               WHERE ma.fingerprint = 'asset14y0ky8jeh009wcmyxcfnfakpgkuq0jcr8d5nxr' \n               \t\tAND tm.key = 721\n               ORDER BY mtm.id DESC LIMIT 1) AS asset_metatdata,\n    tx_out.address AS owner_address,\n    ma.\"time\" AS mint_date\nFROM \n    ma_tx_out mto\nJOIN \n    multi_asset ma ON mto.ident = ma.id\nJOIN \n    tx_out ON mto.tx_out_id = tx_out.id\nLEFT JOIN \n    tx_in ti ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out.INDEX\nLEFT JOIN \n\ttx_metadata tm ON tm.tx_id = tx_out.tx_id\nWHERE \n    ma.fingerprint = 'asset14y0ky8jeh009wcmyxcfnfakpgkuq0jcr8d5nxr'\n    AND ti.tx_out_id IS NULL\nExpected results format\nasset_name   |  encoded_name             |  asset_metadata                           | owner_address\t \t\t\t\t\t\t\t\t\t\t  | mint_date\t\n-------------+---------------------------+-------------------------------------------+------------------------------------------------------------+------------------------\nSpaceBud964  | \t5370616365427564393634   | \t{\"d5e6bf0500378d4f0da4e8dde6be.....  \"}  |  | 2021-03-24 01:18:08.000\n(Note: results trimmed for readability)             \n🔎 Let's take a closer look at each part of the query.The results returned include:\nAsset Name, ie. the human-readable name of the asset ma.name_view.\nEncoded Name... a hexadecimal representation of the asset's name encode(ma.name, 'hex').\nMetadata associated with the asset, specifically looking for key 721 which is often used for NFT metadata tm.json. It selects the most recent metadata entry.\nOwner Address, the current address holding this asset tx_out.address.\nMint Date, ie. the date and time when the asset was created ma.\"time\".\nFROM ma_tx_out mto starts by looking at the multi_asset table, which tracks the association between native assets (tokens/NFTs) and transaction outputs.JOIN multi_asset ma ON mto.ident = ma.id joins with the multi_asset table to get details about the asset itself, like its name and creation time.JOIN tx_out ON mto.tx_out_id = tx_out.id joins with the tx_out table to get information about the transaction output where this asset currently resides, including the owner's address.LEFT JOIN tx_in ti ON ... attempts to join with the tx_in table to find any transaction inputs that spend this specific transaction output.\nLEFT JOIN tx_metadata tm ON tm.tx_id = tx_out.tx_id optionally joins with the tx_metadata table to fetch any metadata associated with the transaction that created the output holding the asset.WHERE ma.fingerprint = '...' AND ti.tx_out_id IS NULL filters results to only include the asset with the specified fingerprint. The ti.tx_out_id IS NULL condition ensures that we only select the transaction output where the asset currently resides (i.e. it hasn't been spent in another transaction).The subquery within the SELECT clause fetches the metadata associated with the asset's minting transaction"}},"/use-cases/nftqueries/nft3":{"title":"Nft3","data":{"3-view-all-assets-that-are-listed-for-sale#3. View all assets that are listed for sale":"For this query, we want to list all assets that are listed for sale at an address. In other words, list all the assets locked in a specific smart contract address eg.  query returns the following details:\nasset name\npolicy ID\nquantity\nSELECT\n\t\tma.policy AS policy,\n\t\tma.name AS name,\n\t\tsum(mto.quantity) AS quantity\n\tFROM\n      \t        ma_tx_out mto\n\tJOIN multi_asset ma \n\t\tON ma.id = mto.ident \n\tJOIN tx_out \n\t\tON mto.tx_out_id = tx_out.id\n\tLEFT JOIN tx_in ti \n\t\tON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out.\"index\"\n\tWHERE\n   \t        tx_out.address = ''\n\t   AND ti.tx_out_id is null\n\tGROUP BY ma.policy, ma.name\n\tORDER BY quantity DESC\nExpected results format\npolicy\t \t\t\t\t\t \t\t\t\t\t\t\t |  name        |  quantity          \n---------------------------------------------------------+--------------+--------------\n | SNEKWRANGLER | 4,500,000,000  \n | \tEL\t\t\t| 1,000,000,000\n | \tFAM\t\t\t| 439,678,272\n | \tFAM\t\t\t| 439,000,000\n | CRAZYMARY\t| 250,000,000\n\t........\t\t\t\t\t\n(Note: results trimmed for readability)             \n🔎 Let's zoom in to understand at each part of the query.FROM ma_tx_out mto looking at the ma_tx_out table, which tracks the association between multi-assets and transaction outputs.JOIN multi_asset ma ON ma.id = mto.ident joins the ma_tx_out table with the multi_asset table to get details about the assets themselves, such as their policy id and name.JOIN tx_out ON mto.tx_out_id = tx_out.id joins with the tx_out table to get information about the transaction outputs where these assets reside, including the address that owns them.LEFT JOIN tx_in ti ON ...: attempts a left join with the tx_in table to identify any transaction inputs that might have spent these transaction outputs.WHERE tx_out.address = '...' AND ti.tx_out_id IS NULL filters the results to only include assets held by the specified address.The condition ti.tx_out_id IS NULL ensures that we only consider transaction outputs that haven't been spent yet.GROUP BY ma.policy, ma.name groups the results by the policy id and name of the assets, effectively aggregating multiple entries for the same asset (if they exist in different transaction outputs).The SELECT ma.policy AS policy, ma.name AS name, sum(mto.quantity) AS quantity retrieves the following For each group (i.e., each unique asset):\nThe policy ID.\nThe asset name.\nThe total quantity of that asset held by the Address\nORDER BY quantity DESC sorts the results in descending order based on the quantity of each asset held."}},"/use-cases/nftqueries/nft4":{"title":"Nft4","data":{"4-minting-an-nft#4. Minting an NFT":"For this query, we assume that the user and backend server have already generated the policyId, policy script, and the metadata necessary for minting NFTs, following CIP-25 and CIP-68 standards. In this example, we will focus on CIP-25.\nExample of how to create a CIP-68 NFT can be found on GitHub, see Nicholas Maselli's CIP-68 Showcase\nBefore proceeding, it’s important to understand the requirements for minting an NFT. Although the overall steps are documented on the Cardano Developer Portal, it’s crucial to note that many of these steps are performed off-chain, typically by the application backend.To successfully mint an NFT, the backend must query specific data from the database to construct the transaction.The required data includes:\nProtocol Parameters: These define various blockchain settings necessary for calculating transaction fees and other parameters.\nUTXOs: The Unspent Transaction Outputs associated with the wallet that will fund the minting transaction.\nSlot/Block Tip: The current slot or block tip to ensure the transaction is valid within the blockchain context.","41-protocol-parameters#4.1 Protocol parameters":"SELECT \n\t\t    ep.epoch_no AS epoch,\n\t\t    ep.min_fee_a,\n\t\t    ep.min_fee_b,\n\t\t    ep.max_block_size,\n\t\t    ep.max_tx_size,\n\t\t    ep.max_bh_size as max_block_header_size,\n\t\t    ep.key_deposit,\n\t\t    ep.pool_deposit,\n\t\t    ep.max_epoch as e_max,\n\t\t    ep.optimal_pool_count as n_opt,\n\t\t    ep.influence as a0,\n\t\t    ep.monetary_expand_rate as rho,\n\t\t    ep.treasury_growth_rate as tau,\n\t\t    ep.decentralisation as decentralisation_param,\n\t\t    ep.extra_entropy,\n\t\t    ep.protocol_major AS protocol_major_ver,\n\t\t    ep.protocol_minor AS protocol_minor_ver,\n\t\t    ep.min_utxo_value AS min_utxo,\n\t\t    ep.min_pool_cost,\n\t\t    ep.nonce,\n\t\t    cm.costs AS cost_models,\n\t\t    ep.price_mem,\n\t\t    ep.price_step,\n\t\t    ep.max_tx_ex_mem,\n\t\t    ep.max_tx_ex_steps,\n\t\t    ep.max_block_ex_mem,\n\t\t    ep.max_block_ex_steps,\n\t\t    ep.max_val_size,\n\t\t    ep.collateral_percent,\n\t\t    ep.max_collateral_inputs,\n\t\t    ep.coins_per_utxo_size,\n\t\t  \tep.coins_per_utxo_size as coins_per_utxo_word\n\t\tFROM \n\t\t    epoch_param ep\n\t\tLEFT JOIN cost_model cm ON cm.id = ep.cost_model_id\n\t\tORDER BY epoch_no DESC\n\t\tLIMIT 1\nExpected results format\nepoch | min_fee_a | min_fee_b | max_block_size | max_tx_size | max_block_header_size | key_deposit | .....\n------+-----------+-----------+----------------+-------------+-----------------------+-------------+------\n505   | 44        | 155,381   | 90,112\t       | 16,384\t     | 1,100\t             | 2,000,000   | ....\n(Note: results trimmed for readability)             \n🔎 Looking a little closer, this query reads data from database, without modifying the blockchain itself. It retrieves information about the protocol parameters for the most recent epoch.SELECT lists the specific columns to retrieve from the database tables.FROM epoch_param ep specifies the main table to query, epoch_param.LEFT JOIN cost_model cm ON cm.id = ep.cost_model_id joins data from the cost_model table based on matching id values.\nORDER BY epoch_no DESC sorts the results by epoch_no in descending order, ie. most recent epoch first.\nLIMIT 1 restricts the output to only the first row, ie. the most recent epoch's data.","42-utxos-associated-with-specific-address#4.2 UTXOs associated with specific address":"Let's use address  as an example for this query.\n        SELECT \n\t\t\ttx.hash AS txhash,\n\t\t\tto2.\"index\" AS tx_out_index,\n\t\t\tto2.value AS value,\n\t\t\tto2.address \n\t\tFROM tx_out to2 \n\t\tLEFT JOIN tx_in ti ON ti.tx_out_id = to2.tx_id AND ti.tx_out_index = to2.\"index\"\n\t\tJOIN tx ON tx.id = to2.tx_id \n\t\tWHERE \n\t\t\tti.id IS NULL\n\t\t\tAND to2.address = ''\nExpected results format\ntxhash\t \t\t|  tx_out_index |  value      | address      \n----------------+---------------+-------------+----------------------\n8cab5...f367073 | \t2 \t\t\t| 6,058,505   | addr1qyv...vgsyxh7q9\n8cab5...f367073 | \t0\t\t\t|   1,159,390 | addr1qyv...vgsyxh7q9\n5ab5b...d7ba36 \t| \t2\t\t\t|   3,062,150 | addr1qyv...vgsyxh7q9\n5ab5b...d7ba36  | \t1\t\t\t|   1,159,390 | addr1qyv...vgsyxh7q9\n(Note: results trimmed for readability)             \n🔎 Looking a little closer, this query returns all unspent transaction outputs (UTXOs) associated with provided address.FROM tx_out to2 starts by selecting all transaction outputs from the tx_out table and assigns them the alias to2.\nLEFT JOIN tx_in ti ON ti.tx_out_id = to2.tx_id AND ti.tx_out_index = to2.\"index\" performs a LEFT JOIN with the tx_in table which stores transaction inputs.The join condition matches tx_out_id and tx_out_index from tx_in to the corresponding tx_id and index from tx_out.A LEFT JOIN ensures that all rows from tx_out are included, even if there's no matching row in tx_in.JOIN tx ON tx.id = to2.tx_id performs an INNER JOIN with the tx table, which stores transactions.This connects each transaction output to2 to its corresponding transaction tx based on the tx_id.WHERE ti.id IS NULL is the crucial part for identifying unspent outputs. It filters the results to only include rows where there's NO matching entry in tx_in. In other words, these are outputs that haven't been used as inputs in any other transaction yet, hence they are \"unspent\".AND to2.address = '' further filters the results to only show UTXOs belonging to our specific address.SELECT tx.hash AS txhash, to2.\"index\" AS tx_out_index, to2.value AS value, to2.address selects the following columns from the filtered results:\ntx.hash ..the transaction hash where the UTXO was created.\nto2.\"index\" ...the index of the UTXO within the transaction.\nto2.value ...the ADA value (or other asset values) associated with the UTXO.\nto2.address ...the address that owns the UTXO","43-chain-tip#4.3 Chain Tip":"SELECT\n\t\t    block.slot_no,\n\t\t    block.block_no,\n\t\t    block.epoch_no,\n\t\t    block.time\n\t\tFROM\n\t\t    block\n\t\tWHERE block.slot_no IS NOT NULL\n\t\tORDER BY\n\t\t    block.slot_no DESC\n\t\tLIMIT 1;\nExpected results format\nslot_no\t    | block_no\t | epoch_no | time\n------------+------------+----------+------------------------\n132,711,492 | 10,734,560 |   504    | 2024-08-21 22:03:03.000\n           \n🔎 Zooming in, this query retrieves information about the chain-tip. In other words, we are looking for the identifier of the most recently processed block on the network.SELECT block.slot_no, block.block_no, block.epoch_no, block.time specifies which columns we want to retrieve from the database. It is looking for:\nblock.slot_no ...the slot number in which the block was created.\nblock.block_no ...the block number within its epoch.\nblock.epoch_no ...the epoch number in which the block was created.\nblock.time ...the timestamp when the block was created.\nFROM block ...this tells the database that we want to get this information from a table called block.WHERE block.slot_no IS NOT NULL is a filter ensuring that we only get rows (blocks) where the slot_no is not empty or null.ORDER BY block.slot_no DESC sorts the results in descending order based on the slot_no. This means the block with the highest slot number (the most recent one) will be at the top.LIMIT 1 limits the output to only one row. Combined with the sorting, this ensures we only get the most recent block."}},"/use-cases/nftqueries/nft5":{"title":"Nft5","data":{"5-selling-an-nft#5. Selling an NFT":"Selling, or listing, an NFT on a marketplace (often referred to as creating an \"ask\", where you offer assets in exchange for ADA) involves utilizing smart contracts. These contracts facilitate secure agreements between parties who may not necessarily trust each other.For this exercise, we'll assume you're already familiar with the concept of smart contracts and understand how they operate. If not, consider reviewing resources such as the Cardano Developer Portal and the Aiken EUTxO crash course to name but a few.The first step in listing an NFT for sale is to create the necessary smart contracts. An example of such a contract can be found in the GitHub repositories of JPG.Store.In our example, we will use the smart contract components for the following information:\nDatum: Contains information such as the owner's public key hash (pkh), the assets being sold, and payout details (e.g., asset cost, artist royalties, marketplace service fees).\nRedeemer: Specifies what actions a user can take with the locked asset, such as “listing”,  “buying or accept“, “canceling”, or “update listing”.\nValidator: It ensures that the signer is the rightful owner, that payouts are correctly configured, and that the appropriate redeemer tag is present so transaction can be successfully processed.\nThese are on-chain components, where datum and redeemer information are stored  in the Ledger Sync database in CBOR and JSON format in the following tables: datum, redeemer_data, and also  referenced on tx_out and failed_tx_out.\nNote: In case if you would like to decode the Datum, you can use Datum Inspector - Cardanoscan\nBefore proceeding, ensure that you have created the script address for user to interact with the smart contract.At this stage, you probably have already implemented wallet connection functionality (e.g., via CIP-30 or in another way), allowing your application to interact with users' wallets.On the Marketplace application, when a user clicks on \"Sell\", the application backend will build a transaction that matches the requirements of the smart contract. This includes:\nSetting the datum with details like the owner of the public key hash, the asset being sold, and all required payouts: asset cost, royalties for the artist, and marketplace service fees. This information is necessary to lock the NFT in the smart contract address, making sure that all requirements are met (based on the smart contract created).\nIncluding the redeemer code, in our example “listing”\nProviding the necessary transaction UTXOs and address inputs and outputs.\nTo successfully build the transaction, you'll need the following data, typically stored in the Ledger Sync database:\nProtocol Parameters: Define blockchain settings necessary for calculating transaction fees and other critical parameters.\nUTXOs: The Unspent Transaction Outputs associated with the wallet that will fund the transaction.\nSlot/Block Tip: The current slot or block tip to ensure the transaction is valid within the blockchain context.\nOnce the required data is gathered, the transaction can be built, signed through the user's wallet, and submitted on-chain. After submission, the validator (code running on-chain) will confirm that all conditions are met, and if so, the NFT will be transferred and locked at the smart contract address.Then, to view assets currently for sale on your marketplace, simply query the smart contract address created for the marketplace.For example, you can check all assets on listings on the JPG.Store marketplace by visiting this address on a Cardano Explorer.Sources:\nJPG.Store Contract V2\nJPG.Store Contract V3\nJPG.Store Next-Gen Smart Contract Update\nIn previous queries, we've already retrieved:\nProtocol parameters\nUTXOs associated to the address below\nChain Tip\nNow we will retrieve all assets locked on a contract address and their respective:\nAsset Name\nAsset policy ID\nAsset Fingerprint\nAmount\nWe will query this address \nSELECT\n\t\t    ma.policy AS policy,\n\t\t    ma.name AS name,\n\t\t    ma.fingerprint AS fingerprint,\n\t\t    sum(mto.quantity) AS quantity\n\t\tFROM\n\t\t    ma_tx_out mto\n\t\tJOIN multi_asset ma \n\t\t\tON ma.id = mto.ident \n\t\tJOIN tx_out \n\t\t\tON mto.tx_out_id = tx_out.id\n\t\tLEFT JOIN tx_in ti \n\t\t\tON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out.\"index\"\n\t\tWHERE\n\t\t    tx_out.address = ''\n\t\t    AND ti.tx_out_id is null\n\t\tGROUP BY ma.policy, ma.name, ma.fingerprint\n\t\tORDER BY quantity DESC\n\t\tLIMIT 10\nExpected results format\npolicy\t    \t\t\t                        \t\t | name                     | fingerprint    \t\t                   \t   | quantity\n---------------------------------------------------------+--------------------------+----------------------------------------------+--------------\n | \tSNEKWRANGLER \t    \t| asset13vuukdg8klkf6px6zt6jq2rqzs0l3gyvjyzhql | 4,500,000,000\n | \tEL\t\t    \t\t\t| asset1flkp5ddlknrdakpw72hmxwkkp0qkfuhlzzn5gw | 1,000,000,000\n | \tFAM\t         \t\t\t| asset1rs7t52lrfxrpz9p8f8egtwdlx4d33mqk62pyuu | 439,678,272\n | \tFAM   \t\t    \t\t| asset1x77jxgfrnn00650gsdtxpuea3k2a6xslaf6key | 439,000,000\n | \tCRAZYMARY\t    \t\t| asset1uxza25kph43w2w6mstuspzmy47rvu4ks898q72 | 250,000,000\n | \\u0000\\u0014�\\u0010FLDT  | asset1gayaljphz3tepway6u6ruuty9cee2pj7wch408 | 180,000,000\n | \tReebokaHoskinson    \t| asset18efh7djgsyat7m8j43etsusxhkv94940adss5k | 150,000,000\n | \tTV\t            \t\t| asset1lr06zsp4qzxv2emchq2j2mfwhqxzgtmxywrrvn | 50,000,000\n | \tStakePool247        \t| asset1946tqd3qe3hq3mxtzg4gkxqupnys0v9tr8v0zt | 25,000,000\n | \tSWS\t\t    \t\t\t| asset1968r7exh3296rls9axexyhqu3lk2c23mn5zjhz | 16,900,000\n           \nNote that some results may display differently in some explorers compared to Ledger Sync results. This is because the 'decimal' parameter of each token may be set differently so a query may return the full data without dividing by decimal, while others divide by a decimal. This parameter is stored in the metadata registry. For the Ledger Sync database, the parameter is set to display the full data.\n🔎 Looking closer, this query retrieves the top 10 native assets held by our specific address.SELECT ma.policy, ma.name, ma.fingerprint, sum(mto.quantity) AS quantity specifies the columns to be retrieved:\nma.policy is the policy ID associated with the asset.\nma.name is the name of the asset.\nma.fingerprint is the unique fingerprint of the asset.\nsum(mto.quantity) AS quantity calculates the total quantity of each asset held by the address.\nFROM ma_tx_out mto selects data from the ma_tx_out table, which stores information about asset transaction outputs.JOIN multi_asset ma ON ma.id = mto.ident joins the ma_tx_out table with the multi_asset table based on matching id and ident values. This links the transaction output information with the details of the asset itself.JOIN tx_out ON mto.tx_out_id = tx_out.id joins the result with the tx_out table to get the transaction output details associated with the asset outputs.LEFT JOIN tx_in ti ON ti.tx_out_id = tx_out.tx_id AND ti.tx_out_index = tx_out.\"index\" performs a left join with the tx_in table to identify which transaction outputs have been spent (used as inputs in other transactions).WHERE tx_out.address = '' AND ti.tx_out_id is null filters the results to only include:\nTransaction outputs belonging to the specified  address.\nTransaction outputs that have not been spent (i.e., ti.tx_out_id is null). This ensures we're only looking at the unspent assets (the ones the address currently holds).\nGROUP BY ma.policy, ma.name, ma.fingerprint groups the results by the policy, name, and fingerprint of the asset, allowing us to calculate the total quantity of each unique asset held.ORDER BY quantity DESC sorts the results in descending order based on the calculated quantity. This puts the assets with the highest quantities at the top.LIMIT 10 limits the output to the top 10 results."}},"/use-cases/nftqueries/nft6":{"title":"Nft6","data":{"6-buying-an-nft#6. Buying an NFT":"Buying an NFT on a marketplace (often referred to as placing a \"bid,\" where you offer ADA in exchange for assets) involves the use of smart contracts. These contracts facilitate secure agreements between parties who may not necessarily trust each other.For this exercise, we'll assume you're already familiar with the concept of smart contracts and understand how they operate. If not, consider reviewing resources such as the Cardano Developer Portal and the Aiken EUTxO crash course to name but a few.","steps-to-buy-an-nft#Steps to Buy an NFT":"The first step in buying an NFT is to select the one you want to make an offer on. To do this, refer to the “View Assets for Sale” query to see all assets listed on the marketplace.After choosing the NFT, a similar process occurs as when you are selling an NFT (refer to the previous “Selling an NFT\" example for details).On the Marketplace application, when a user clicks on \"Buy\", the application backend will build a transaction that matches the requirements of the smart contract. This includes:\nSetting the datum with details like amount of ADA charged by the asset, royalties for the artist, and marketplace service fees. This step is necessary to unlock the NFT in the transaction, ensuring all required payouts are fulfilled.\nIncluding the redeemer code, in our example “accept” (accept the offer/listing requirements).\nProviding the necessary transaction UTXOs and address, inputs and outputs.\nTo successfully build the transaction, you'll need the following data, typically stored in the Ledger Sync database:\nProtocol Parameters: Define blockchain settings necessary for calculating transaction fees and other critical parameters.\nUTXOs: The Unspent Transaction Outputs associated with the wallet that will fund the transaction.\nSlot/Block Tip: The current slot or block tip to ensure the transaction is valid within the blockchain context.\nOnce the required data is gathered, the transaction can be built, signed through the user's wallet, and submitted on-chain. After submission, the validator will confirm that all conditions are met, and if so, and the NFT will be transferred to the buyer's wallet and if any, a change.To make sure that the asset has been transferred from the smart contract address to your wallet, you can use the following query: Breakdown list of all tokens or NFTs held in the wallet.All of what just described is returned in the various wallet and NFT queries we discussed previously."}}}